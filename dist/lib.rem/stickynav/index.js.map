{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6*****","webpack:////lib.rem/stickynav/index.js","webpack:///webpack/bootstrap 724a6030bf776d82d1c1?d85d*****","webpack:///./src/components/stickynav/index.js","webpack:///./~/_vue-loader@10.3.0@vue-loader/lib/component-normalizer.js?5987*****","webpack:///./~/_css-loader@0.26.4@css-loader/lib/css-base.js?54ee*****","webpack:///./~/_vue-style-loader@2.0.5@vue-style-loader/lib/addStylesClient.js?ba72*****","webpack:///./~/_vue-style-loader@2.0.5@vue-style-loader/lib/listToStyles.js?190a*****","webpack:///./src/utils/assist.js?3376***","webpack:///sticky-panel.vue","webpack:///stickynav.vue","webpack:///./src/components/stickynav/src/stickynav.vue?a972","webpack:///./~/_intersection-observer@0.5.0@intersection-observer/intersection-observer.js","webpack:///./~/_jump.js@1.0.2@jump.js/dist/jump.js","webpack:///./~/_scrollama@1.4.4@scrollama/build/scrollama.js","webpack:///./~/_stickyfilljs@2.1.0@stickyfilljs/dist/stickyfill.js","webpack:///./src/components/stickynav/src/sticky-panel.vue","webpack:///./src/components/stickynav/src/stickynav.vue","webpack:///./src/components/stickynav/src/sticky-panel.vue?555f","webpack:///./src/components/stickynav/src/stickynav.vue?a0b9","webpack:///./src/components/stickynav/src/stickynav.vue?562c"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","0","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","StickyPanel","StickyNav","undefined","_stickynav","_stickynav2","_stickyPanel","_stickyPanel2","1","rawScriptExports","compiledTemplate","scopeId","cssModules","esModule","scriptExports","type","options","render","staticRenderFns","_scopeId","computed","keys","forEach","key","2","list","toString","result","i","length","item","push","join","mediaQuery","alreadyImportedModules","3","addStylesToDom","styles","domStyle","stylesInDom","refs","j","parts","addStyle","createStyleElement","styleElement","document","createElement","head","appendChild","update","remove","querySelector","isProduction","noop","parentNode","removeChild","isOldIE","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","bind","applyToTag","newObj","css","media","sourceMap","index","styleSheet","cssText","replaceText","cssNode","createTextNode","childNodes","insertBefore","setAttribute","sources","btoa","unescape","encodeURIComponent","JSON","stringify","firstChild","hasDocument","listToStyles","getElementsByTagName","navigator","test","userAgent","toLowerCase","parentId","_isProduction","newList","mayRemove","textStore","replacement","filter","Boolean","4","newStyles","part","5","pageScroll","fn","e","preventDefault","stopPropagation","islock","lock","el","addEventListener","unlock","removeEventListener","preventScroll","bodyCls","scrollTop","scrollingElement","body","classList","add","style","top","isIOS","window","match","isColor","colorReg","rgbaReg","rgbReg","getPos","ele","t","offsetTop","offsetParent","getScrollview","currentNode","tagName","nodeType","overflowY","defaultView","getComputedStyle","checkInview","scrollView","contentHeight","offsetHeight","contentTop","getBoundingClientRect","post","posb","hasClass","elem","cls","replace","RegExp","className","addClass","removeClass","newClass","indexOf","scroll","start","end","step","callback","d","scrollTo","requestAnimationFrame","from","arguments","to","duration","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","setTimeout","difference","Math","abs","ceil","99","name","data","isCurrent","props","label","String","active","tabkey","Number","classes","$parent","activeIndex","_uid","watch","init","mounted","_this","$nextTick","100","_scrollama","_scrollama2","_assist","_jump","_jump2","currentKey","navList","tmpIndex","tabPanels","change","Function","activeColor","validator","offset","methods","emitChange","changeHandler","uid","panel","$el","navOffSet","handleStepEnter","response","$children","$options","panelList","scroller","setup","container","graphic","text","onStepEnter","resizeHandler","$refs","console","log","resize","created","inited","140","158","IntersectionObserverEntry","entry","time","target","rootBounds","boundingClientRect","intersectionRect","getEmptyRect","isIntersecting","targetRect","targetArea","width","height","intersectionArea","intersectionRatio","IntersectionObserver","opt_options","Error","_checkForIntersections","throttle","THROTTLE_TIMEOUT","_callback","_observationTargets","_queuedEntries","_rootMarginValues","_parseRootMargin","rootMargin","thresholds","_initThresholds","threshold","map","margin","unit","now","performance","timeout","timer","addEvent","node","event","opt_useCapture","attachEvent","removeEvent","detatchEvent","computeRectIntersection","rect1","rect2","max","bottom","min","left","right","rect","err","containsDeep","parent","child","getParentNode","host","prototype","get","registry","POLL_INTERVAL","USE_MUTATION_OBSERVER","observe","isTargetAlreadyObserved","some","element","_registerInstance","_monitorIntersections","unobserve","_unmonitorIntersections","_unregisterInstance","disconnect","takeRecords","records","slice","opt_threshold","Array","isArray","sort","a","isNaN","opt_rootMargin","marginString","margins","split","exec","parseFloat","_monitoringIntersections","_monitoringInterval","setInterval","_domObserver","MutationObserver","attributes","childList","characterData","subtree","clearInterval","rootIsInDom","_rootIsInDom","rootRect","_getRootRect","rootContainsTarget","_rootContainsTarget","oldEntry","_computeTargetAndRootIntersection","newEntry","_hasCrossedThreshold","display","atRoot","parentRect","parentComputedStyle","documentElement","overflow","html","clientWidth","clientHeight","_expandRectByRootMargin","newRect","oldRatio","newRatio","splice","159","global","easeInOutQuad","b","_typeof","Symbol","iterator","constructor","jumper","location","scrollY","pageYOffset","loop","timeCurrent","timeStart","timeElapsed","next","easing","distance","done","a11y","focus","jump","stop","singleton","165","selectionToArray","selection","len","select","selector","Element","selectAll","querySelectorAll","NodeList","getStepId","ref","getOffsetId","setupOffset","offsetVal","stepClass","position","borderTop","zIndex","innerText","fontSize","fontFamily","color","padding","stepEl","getAttribute","updateOffset","offsetMargin","idVal","stepOffsetHeight","notifyStep","state","elA","elB","scrollama","generateId","l","Date","getTime","r","floor","random","getOffsetTop","getPageHeight","scrollHeight","getIndex","updateDirection","previousYOffset","direction","handleResize","vh","innerHeight","ph","bboxGraphic","graphicEl","stepOffsetTop","isEnabled","isReady","updateIO","debugMode","handleEnable","enable","io","stepAbove","stepBelow","stepProgress","viewportAbove","viewportBelow","createThreshold","count","progressThreshold","ratio","notifyOthers","ss","stepStates","notifyStepExit","notifyStepEnter","i$1","ss$1","check","resp","preserveOrder","stepEnter","exclude","triggerOnce","progressMode","notifyStepProgress","stepExit","progress","notifyContainerEnter","containerState","containerEnter","notifyContainerExit","containerExit","intersectStepAbove","entries","bottomAdjusted","ZERO_MOE","intersectStepBelow","intersectViewportAbove","intersectViewportBelow","intersectStepProgress","toFixed","intersectTop","intersectBottom","updateTopIO","containerEl","updateBottomIO","updateStepAboveIO","marginTop","marginBottom","obs","updateStepBelowIO","updateViewportAboveIO","updateViewportBelowIO","updateStepProgressIO","indexSteps","setupStates","addDebug","S","debug","order","once","offsetTrigger","error","disable","destroy","x","cb","onStepExit","onStepProgress","onContainerEnter","onContainerExit","166","_classCallCheck","instance","Constructor","TypeError","extend","targetObj","sourceObject","hasOwnProperty","parseNumeric","val","getDocOffsetTop","docOffsetTop","checkScroll","pageXOffset","Stickyfill","refreshAll","stickies","sticky","_recalcPosition","startFastCheckTimer","fastCheckTimer","_fastCheck","stopFastCheckTimer","isInitialized","docHiddenKey","visibilityChangeEventName","_createClass","defineProperties","descriptor","enumerable","configurable","writable","protoProps","staticProps","seppuku","isWindowDefined","testNode","prefix","shadowRootExists","ShadowRoot","Sticky","HTMLElement","_node","_stickyMode","_active","refresh","_removed","_deactivate","nodeComputedStyle","nodeComputedProps","marginLeft","marginRight","cssFloat","originalPosition","referenceNode","nodeWinOffset","parentWinOffset","_parent","_offsetToWindow","_offsetToParent","borderTopWidth","borderLeftWidth","borderRightWidth","_styles","nodeTopValue","_limits","borderBottomWidth","parentPosition","clone","_clone","border","borderSpacing","stickyMode","_this2","forceSticky","addOne","nodeList","addedStickies","_loop","removeOne","_loop2","removeAll","232","Component","233","250","_vm","_h","$createElement","_c","_self","staticClass","class","_t","290","_v","directives","rawName","expression","_l","on","click","$event","attrs","href","_s","341","content","locals"],"mappings":"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","file":"/lib.rem/stickynav/index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ydui\"] = factory();\n\telse\n\t\troot[\"ydui\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","/*! vue-ydui v1.2.0 by YDCSS (c) 2018 Licensed MIT */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ydui\"] = factory();\n\telse\n\t\troot[\"ydui\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.StickyPanel = exports.StickyNav = undefined;\n\t\n\tvar _stickynav = __webpack_require__(233);\n\t\n\tvar _stickynav2 = _interopRequireDefault(_stickynav);\n\t\n\tvar _stickyPanel = __webpack_require__(232);\n\t\n\tvar _stickyPanel2 = _interopRequireDefault(_stickyPanel);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.StickyNav = _stickynav2.default;\n\texports.StickyPanel = _stickyPanel2.default;\n\n/***/ }),\n\n/***/ 1:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function normalizeComponent (\n\t  rawScriptExports,\n\t  compiledTemplate,\n\t  scopeId,\n\t  cssModules\n\t) {\n\t  var esModule\n\t  var scriptExports = rawScriptExports = rawScriptExports || {}\n\t\n\t  // ES6 modules interop\n\t  var type = typeof rawScriptExports.default\n\t  if (type === 'object' || type === 'function') {\n\t    esModule = rawScriptExports\n\t    scriptExports = rawScriptExports.default\n\t  }\n\t\n\t  // Vue.extend constructor export interop\n\t  var options = typeof scriptExports === 'function'\n\t    ? scriptExports.options\n\t    : scriptExports\n\t\n\t  // render functions\n\t  if (compiledTemplate) {\n\t    options.render = compiledTemplate.render\n\t    options.staticRenderFns = compiledTemplate.staticRenderFns\n\t  }\n\t\n\t  // scopedId\n\t  if (scopeId) {\n\t    options._scopeId = scopeId\n\t  }\n\t\n\t  // inject cssModules\n\t  if (cssModules) {\n\t    var computed = options.computed || (options.computed = {})\n\t    Object.keys(cssModules).forEach(function (key) {\n\t      var module = cssModules[key]\n\t      computed[key] = function () { return module }\n\t    })\n\t  }\n\t\n\t  return {\n\t    esModule: esModule,\n\t    exports: scriptExports,\n\t    options: options\n\t  }\n\t}\n\n\n/***/ }),\n\n/***/ 2:\n/***/ (function(module, exports) {\n\n\t/*\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\n\t\tAuthor Tobias Koppers @sokra\n\t*/\n\t// css base code, injected by the css-loader\n\tmodule.exports = function() {\n\t\tvar list = [];\n\t\n\t\t// return the list of modules as css string\n\t\tlist.toString = function toString() {\n\t\t\tvar result = [];\n\t\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\t\tvar item = this[i];\n\t\t\t\tif(item[2]) {\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\n\t\t\t\t} else {\n\t\t\t\t\tresult.push(item[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result.join(\"\");\n\t\t};\n\t\n\t\t// import a list of modules into the list\n\t\tlist.i = function(modules, mediaQuery) {\n\t\t\tif(typeof modules === \"string\")\n\t\t\t\tmodules = [[null, modules, \"\"]];\n\t\t\tvar alreadyImportedModules = {};\n\t\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\t\tvar id = this[i][0];\n\t\t\t\tif(typeof id === \"number\")\n\t\t\t\t\talreadyImportedModules[id] = true;\n\t\t\t}\n\t\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\t\tvar item = modules[i];\n\t\t\t\t// skip already imported module\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t\t}\n\t\t\t\t\tlist.push(item);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn list;\n\t};\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*\n\t  MIT License http://www.opensource.org/licenses/mit-license.php\n\t  Author Tobias Koppers @sokra\n\t  Modified by Evan You @yyx990803\n\t*/\n\t\n\tvar hasDocument = typeof document !== 'undefined'\n\t\n\tif (false) {\n\t  if (!hasDocument) {\n\t    throw new Error(\n\t    'vue-style-loader cannot be used in a non-browser environment. ' +\n\t    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n\t  ) }\n\t}\n\t\n\tvar listToStyles = __webpack_require__(4)\n\t\n\t/*\n\ttype StyleObject = {\n\t  id: number;\n\t  parts: Array<StyleObjectPart>\n\t}\n\t\n\ttype StyleObjectPart = {\n\t  css: string;\n\t  media: string;\n\t  sourceMap: ?string\n\t}\n\t*/\n\t\n\tvar stylesInDom = {/*\n\t  [id: number]: {\n\t    id: number,\n\t    refs: number,\n\t    parts: Array<(obj?: StyleObjectPart) => void>\n\t  }\n\t*/}\n\t\n\tvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\n\tvar singletonElement = null\n\tvar singletonCounter = 0\n\tvar isProduction = false\n\tvar noop = function () {}\n\t\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\t\n\tmodule.exports = function (parentId, list, _isProduction) {\n\t  isProduction = _isProduction\n\t\n\t  var styles = listToStyles(parentId, list)\n\t  addStylesToDom(styles)\n\t\n\t  return function update (newList) {\n\t    var mayRemove = []\n\t    for (var i = 0; i < styles.length; i++) {\n\t      var item = styles[i]\n\t      var domStyle = stylesInDom[item.id]\n\t      domStyle.refs--\n\t      mayRemove.push(domStyle)\n\t    }\n\t    if (newList) {\n\t      styles = listToStyles(parentId, newList)\n\t      addStylesToDom(styles)\n\t    } else {\n\t      styles = []\n\t    }\n\t    for (var i = 0; i < mayRemove.length; i++) {\n\t      var domStyle = mayRemove[i]\n\t      if (domStyle.refs === 0) {\n\t        for (var j = 0; j < domStyle.parts.length; j++) {\n\t          domStyle.parts[j]()\n\t        }\n\t        delete stylesInDom[domStyle.id]\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction addStylesToDom (styles /* Array<StyleObject> */) {\n\t  for (var i = 0; i < styles.length; i++) {\n\t    var item = styles[i]\n\t    var domStyle = stylesInDom[item.id]\n\t    if (domStyle) {\n\t      domStyle.refs++\n\t      for (var j = 0; j < domStyle.parts.length; j++) {\n\t        domStyle.parts[j](item.parts[j])\n\t      }\n\t      for (; j < item.parts.length; j++) {\n\t        domStyle.parts.push(addStyle(item.parts[j]))\n\t      }\n\t      if (domStyle.parts.length > item.parts.length) {\n\t        domStyle.parts.length = item.parts.length\n\t      }\n\t    } else {\n\t      var parts = []\n\t      for (var j = 0; j < item.parts.length; j++) {\n\t        parts.push(addStyle(item.parts[j]))\n\t      }\n\t      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n\t    }\n\t  }\n\t}\n\t\n\tfunction createStyleElement () {\n\t  var styleElement = document.createElement('style')\n\t  styleElement.type = 'text/css'\n\t  head.appendChild(styleElement)\n\t  return styleElement\n\t}\n\t\n\tfunction addStyle (obj /* StyleObjectPart */) {\n\t  var update, remove\n\t  var styleElement = document.querySelector('style[data-vue-ssr-id~=\"' + obj.id + '\"]')\n\t\n\t  if (styleElement) {\n\t    if (isProduction) {\n\t      // has SSR styles and in production mode.\n\t      // simply do nothing.\n\t      return noop\n\t    } else {\n\t      // has SSR styles but in dev mode.\n\t      // for some reason Chrome can't handle source map in server-rendered\n\t      // style tags - source maps in <style> only works if the style tag is\n\t      // created and inserted dynamically. So we remove the server rendered\n\t      // styles and inject new ones.\n\t      styleElement.parentNode.removeChild(styleElement)\n\t    }\n\t  }\n\t\n\t  if (isOldIE) {\n\t    // use singleton mode for IE9.\n\t    var styleIndex = singletonCounter++\n\t    styleElement = singletonElement || (singletonElement = createStyleElement())\n\t    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n\t    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n\t  } else {\n\t    // use multi-style-tag mode in all other cases\n\t    styleElement = createStyleElement()\n\t    update = applyToTag.bind(null, styleElement)\n\t    remove = function () {\n\t      styleElement.parentNode.removeChild(styleElement)\n\t    }\n\t  }\n\t\n\t  update(obj)\n\t\n\t  return function updateStyle (newObj /* StyleObjectPart */) {\n\t    if (newObj) {\n\t      if (newObj.css === obj.css &&\n\t          newObj.media === obj.media &&\n\t          newObj.sourceMap === obj.sourceMap) {\n\t        return\n\t      }\n\t      update(obj = newObj)\n\t    } else {\n\t      remove()\n\t    }\n\t  }\n\t}\n\t\n\tvar replaceText = (function () {\n\t  var textStore = []\n\t\n\t  return function (index, replacement) {\n\t    textStore[index] = replacement\n\t    return textStore.filter(Boolean).join('\\n')\n\t  }\n\t})()\n\t\n\tfunction applyToSingletonTag (styleElement, index, remove, obj) {\n\t  var css = remove ? '' : obj.css\n\t\n\t  if (styleElement.styleSheet) {\n\t    styleElement.styleSheet.cssText = replaceText(index, css)\n\t  } else {\n\t    var cssNode = document.createTextNode(css)\n\t    var childNodes = styleElement.childNodes\n\t    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n\t    if (childNodes.length) {\n\t      styleElement.insertBefore(cssNode, childNodes[index])\n\t    } else {\n\t      styleElement.appendChild(cssNode)\n\t    }\n\t  }\n\t}\n\t\n\tfunction applyToTag (styleElement, obj) {\n\t  var css = obj.css\n\t  var media = obj.media\n\t  var sourceMap = obj.sourceMap\n\t\n\t  if (media) {\n\t    styleElement.setAttribute('media', media)\n\t  }\n\t\n\t  if (sourceMap) {\n\t    // https://developer.chrome.com/devtools/docs/javascript-debugging\n\t    // this makes source maps inside style tags work properly in Chrome\n\t    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n\t    // http://stackoverflow.com/a/26603875\n\t    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n\t  }\n\t\n\t  if (styleElement.styleSheet) {\n\t    styleElement.styleSheet.cssText = css\n\t  } else {\n\t    while (styleElement.firstChild) {\n\t      styleElement.removeChild(styleElement.firstChild)\n\t    }\n\t    styleElement.appendChild(document.createTextNode(css))\n\t  }\n\t}\n\n\n/***/ }),\n\n/***/ 4:\n/***/ (function(module, exports) {\n\n\t/**\n\t * Translates the list format produced by css-loader into something\n\t * easier to manipulate.\n\t */\n\tmodule.exports = function listToStyles (parentId, list) {\n\t  var styles = []\n\t  var newStyles = {}\n\t  for (var i = 0; i < list.length; i++) {\n\t    var item = list[i]\n\t    var id = item[0]\n\t    var css = item[1]\n\t    var media = item[2]\n\t    var sourceMap = item[3]\n\t    var part = {\n\t      id: parentId + ':' + i,\n\t      css: css,\n\t      media: media,\n\t      sourceMap: sourceMap\n\t    }\n\t    if (!newStyles[id]) {\n\t      styles.push(newStyles[id] = { id: id, parts: [part] })\n\t    } else {\n\t      newStyles[id].parts.push(part)\n\t    }\n\t  }\n\t  return styles\n\t}\n\n\n/***/ }),\n\n/***/ 5:\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\tvar pageScroll = function () {\n\t    var fn = function fn(e) {\n\t        e.preventDefault();\n\t        e.stopPropagation();\n\t    };\n\t    var islock = false;\n\t\n\t    return {\n\t        lock: function lock(el) {\n\t            if (islock) return;\n\t            islock = true;\n\t            (el || document).addEventListener('touchmove', fn);\n\t        },\n\t        unlock: function unlock(el) {\n\t            islock = false;\n\t            (el || document).removeEventListener('touchmove', fn);\n\t        }\n\t    };\n\t}();\n\t\n\tvar preventScroll = function (bodyCls) {\n\t    var scrollTop = void 0;\n\t    return {\n\t        lock: function lock() {\n\t            scrollTop = document.scrollingElement.scrollTop;\n\t            document.body.classList.add(bodyCls);\n\t            document.body.style.top = -scrollTop + 'px';\n\t        },\n\t        unlock: function unlock() {\n\t            document.body.classList.remove(bodyCls);\n\t            document.scrollingElement.scrollTop = scrollTop;\n\t        }\n\t    };\n\t}('g-fix-ios-prevent-scroll');\n\t//此方法完美解决滚动穿透问题\n\t\n\tvar isIOS = !!(window.navigator && window.navigator.userAgent || '').match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/);\n\t\n\tvar isColor = function isColor(value) {\n\t    var colorReg = /^#([a-fA-F0-9]){3}(([a-fA-F0-9]){3})?$/;\n\t    var rgbaReg = /^[rR][gG][bB][aA]\\(\\s*((25[0-5]|2[0-4]\\d|1?\\d{1,2})\\s*,\\s*){3}\\s*(\\.|\\d+\\.)?\\d+\\s*\\)$/;\n\t    var rgbReg = /^[rR][gG][bB]\\(\\s*((25[0-5]|2[0-4]\\d|1?\\d{1,2})\\s*,\\s*){2}(25[0-5]|2[0-4]\\d|1?\\d{1,2})\\s*\\)$/;\n\t\n\t    return colorReg.test(value) || rgbaReg.test(value) || rgbReg.test(value);\n\t};\n\tvar getPos = function getPos(ele) {\n\t    var t = ele.offsetTop;\n\t    while (ele = ele.offsetParent) {\n\t        t += ele.offsetTop;\n\t    }\n\t    return t;\n\t};\n\t\n\tvar getScrollview = function getScrollview(el) {\n\t    var currentNode = el;\n\t    while (currentNode && currentNode.tagName !== 'HTML' && currentNode.tagName !== 'BODY' && currentNode.nodeType === 1) {\n\t        var overflowY = document.defaultView.getComputedStyle(currentNode).overflowY;\n\t        if (overflowY === 'scroll' || overflowY === 'auto') {\n\t            return currentNode;\n\t        }\n\t        currentNode = currentNode.parentNode;\n\t    }\n\t    return window;\n\t};\n\t\n\tvar checkInview = function checkInview(scrollView, el) {\n\t    var contentHeight = scrollView === window ? document.body.offsetHeight : scrollView.offsetHeight;\n\t    var contentTop = scrollView === window ? 0 : scrollView.getBoundingClientRect().top;\n\t\n\t    var post = el.getBoundingClientRect().top - contentTop;\n\t    var posb = post + el.offsetHeight;\n\t\n\t    return post >= 0 && post < contentHeight || posb > 0 && posb <= contentHeight;\n\t};\n\t\n\tvar hasClass = function hasClass(elem, cls) {\n\t    cls = cls || '';\n\t    if (cls.replace(/\\s/g, '').length === 0 || !elem) return false;\n\t    return new RegExp(' ' + cls + ' ').test(' ' + elem.className + ' ');\n\t};\n\t\n\tvar addClass = function addClass(ele, cls) {\n\t    if (!hasClass(ele, cls)) {\n\t        ele.className = ele.className === '' ? cls : ele.className + ' ' + cls;\n\t    }\n\t};\n\t\n\tvar removeClass = function removeClass(ele, cls) {\n\t    if (hasClass(ele, cls)) {\n\t        var newClass = ' ' + ele.className.replace(/[\\t\\r\\n]/g, '') + ' ';\n\t        while (newClass.indexOf(' ' + cls + ' ') >= 0) {\n\t            newClass = newClass.replace(' ' + cls + ' ', ' ');\n\t        }\n\t        ele.className = newClass.replace(/^\\s+|\\s+$/g, '');\n\t    }\n\t};\n\t\n\t//Copy from iView. https://www.iviewui.com/\n\tvar scrollTop = function scrollTop(el) {\n\t    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t    var to = arguments[2];\n\t    var duration = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 500;\n\t    var callback = arguments[4];\n\t\n\t    if (!window.requestAnimationFrame) {\n\t        window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {\n\t            return window.setTimeout(callback, 1000 / 60);\n\t        };\n\t    }\n\t    var difference = Math.abs(from - to);\n\t    var step = Math.ceil(difference / duration * 50);\n\t\n\t    function scroll(start, end, step) {\n\t        if (start === end) {\n\t            typeof callback === 'function' && callback();\n\t            return;\n\t        }\n\t\n\t        var d = start + step > end ? end : start + step;\n\t        if (start > end) {\n\t            d = start - step < end ? end : start - step;\n\t        }\n\t\n\t        if (el === window) {\n\t            window.scrollTo(d, d);\n\t        } else {\n\t            el.scrollTop = d;\n\t        }\n\t        window.requestAnimationFrame(function () {\n\t            return scroll(d, end, step);\n\t        });\n\t    }\n\t\n\t    scroll(from, to, step);\n\t};\n\t\n\texports.pageScroll = pageScroll;\n\texports.preventScroll = preventScroll;\n\texports.isIOS = isIOS;\n\texports.isColor = isColor;\n\texports.getPos = getPos;\n\texports.getScrollview = getScrollview;\n\texports.checkInview = checkInview;\n\texports.addClass = addClass;\n\texports.removeClass = removeClass;\n\texports.scrollTop = scrollTop;\n\n/***/ }),\n\n/***/ 99:\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t\n\texports.default = {\n\t    name: 'yd-sticky-panel',\n\t    data: function data() {\n\t        return {\n\t            isCurrent: false\n\t        };\n\t    },\n\t\n\t    props: {\n\t        label: String,\n\t        active: Boolean,\n\t        tabkey: [String, Number]\n\t    },\n\t    computed: {\n\t        classes: function classes() {\n\t            return this.$parent.activeIndex === this._uid || this.isCurrent ? 'yd-tab-active' : '';\n\t        }\n\t    },\n\t    watch: {\n\t        active: function active() {\n\t            this.$parent.init();\n\t        },\n\t        label: function label() {\n\t            this.$parent.init();\n\t        }\n\t    },\n\t    mounted: function mounted() {\n\t        var _this = this;\n\t\n\t        this.$nextTick(function () {\n\t            _this.$parent.init();\n\t        });\n\t    }\n\t};\n\n/***/ }),\n\n/***/ 100:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\t__webpack_require__(158);\n\t\n\t__webpack_require__(166);\n\t\n\tvar _scrollama = __webpack_require__(165);\n\t\n\tvar _scrollama2 = _interopRequireDefault(_scrollama);\n\t\n\tvar _assist = __webpack_require__(5);\n\t\n\tvar _jump = __webpack_require__(159);\n\t\n\tvar _jump2 = _interopRequireDefault(_jump);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t    name: \"yd-sticky-nav\",\n\t    data: function data() {\n\t        return {\n\t            currentKey: '',\n\t            navList: [],\n\t            activeIndex: 0,\n\t            tmpIndex: 0,\n\t            tabPanels: []\n\t        };\n\t    },\n\t\n\t    props: {\n\t        change: Function,\n\t        callback: Function,\n\t        activeColor: {\n\t            validator: function validator(value) {\n\t                if (!value) return true;\n\t                return (0, _assist.isColor)(value);\n\t            },\n\t\n\t            default: '#005bac'\n\t        },\n\t        offset: {\n\t            type: Number,\n\t            default: 0\n\t        }\n\t    },\n\t    methods: {\n\t        emitChange: function emitChange(label, tabkey) {\n\t            this.callback && this.callback(label, tabkey);\n\t        },\n\t        changeHandler: function changeHandler(uid, label, tabkey, panel, index) {\n\t            if (this.tmpIndex != uid) {\n\t                this.activeIndex = this.tmpIndex = uid;\n\t                this.emitChange(label, tabkey);\n\t            }\n\t            (0, _jump2.default)(panel.$el, { offset: -this.navOffSet, duration: 400 });\n\t        },\n\t        handleStepEnter: function handleStepEnter(response) {\n\t            this.activeIndex = this.navList[response.index]._uid;\n\t        },\n\t        init: function init() {\n\t            var _this = this;\n\t\n\t            var topHeigth = 0; //this.$refs.banner.offsetHeight+this.$refs.stickyNav.offsetHeight\n\t            var tabPanels = this.$children.filter(function (item) {\n\t                return item.$options.name === 'yd-sticky-panel';\n\t            });\n\t            this.navList = [];\n\t            var panelList = [];\n\t            tabPanels.forEach(function (panel, index) {\n\t                _this.navList.push({\n\t                    _uid: panel._uid,\n\t                    label: panel.label,\n\t                    tabkey: panel.tabkey,\n\t                    panel: panel\n\t                });\n\t                panelList.push(panel.$el);\n\t            });\n\t            if (!this.scroller) {\n\t                this.scroller = (0, _scrollama2.default)();\n\t                this.scroller.setup({\n\t                    container: '.scroll', // required (for sticky)\n\t                    graphic: '.scroll__graphic', // required (for sticky)\n\t                    text: '.scroll__text',\n\t                    step: panelList,\n\t                    offset: 0.33\n\t                }).onStepEnter(this.handleStepEnter);\n\t                this.$nextTick(function () {\n\t                    window.addEventListener('resize', _this.resizeHandler);\n\t                    _this.navOffSet = _this.$refs['stickyNav'].offsetHeight + _this.offset;\n\t                });\n\t            }\n\t        },\n\t        resizeHandler: function resizeHandler() {\n\t            console.log(\"窗口重置\");\n\t            this.scroller.resize();\n\t        }\n\t    },\n\t    mounted: function mounted() {},\n\t    created: function created() {\n\t        this.inited = false;\n\t        this.scroller;\n\t        this.navOffSet = this.offset;\n\t    }\n\t}; //\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\n/***/ }),\n\n/***/ 140:\n/***/ (function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(2)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".yd-tab-box[data-v-6b20fd57]{overflow:auto;-webkit-overflow-scrolling:touch;background-color:#fff}.yd-tab-nav-nomal .yd-tab-nav[data-v-6b20fd57]{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap}.yd-tab-nav-nomal .yd-tab-nav .yd-tab-nav-item[data-v-6b20fd57]{white-space:nowrap;padding-left:8px;padding-right:8px;-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1}.yd-tab-nav-scoll .yd-tab-nav .yd-tab-nav-item[data-v-6b20fd57]{padding:0 20px;display:inline-block}.yd-tab-nav[data-v-6b20fd57]{position:relative;z-index:0}.yd-tab-nav[data-v-6b20fd57]:after{height:1px;position:absolute;z-index:3;bottom:0;left:0;content:\\\"\\\";width:100%;background-image:-webkit-gradient(linear,left bottom,left top,color-stop(50%,#b2b2b2),color-stop(50%,transparent));background-image:-webkit-linear-gradient(bottom,#b2b2b2 50%,transparent 0);background-image:linear-gradient(0deg,#b2b2b2 50%,transparent 0)}.yd-tab-nav-item[data-v-6b20fd57]{-webkit-transition:background-color .25s cubic-bezier(.8,.1,.1,1) 0s;transition:background-color .25s cubic-bezier(.8,.1,.1,1) 0s;position:relative;text-align:center;color:#585858;font-size:14px;line-height:30px;background-color:#fff}.yd-tab-nav-item[data-v-6b20fd57]:active{background-color:#f7f7f7}.yd-tab-nav-item>a[data-v-6b20fd57]{display:inherit;color:inherit}.yd-tab-nav-item[data-v-6b20fd57]:not(:last-child):after{position:absolute;top:35%;right:0;content:\\\"\\\";width:1px;height:30%;-webkit-transform:scaleX(.5);transform:scaleX(.5);border-right:1px solid #d9d9d9}.yd-tab-nav .yd-tab-active[data-v-6b20fd57]{color:currentColor;background-color:#fff}.yd-tab-nav .yd-tab-active[data-v-6b20fd57]:active{background-color:#fff}.yd-tab-nav .yd-tab-active[data-v-6b20fd57]:before{content:\\\"\\\";width:70%;height:2px;position:absolute;left:50%;bottom:0;margin-left:-35%;z-index:4;background-color:currentColor}.yd-tab-panel[data-v-6b20fd57]{position:relative;overflow:hidden;background-color:#fff}.yd-tab-panel-item[data-v-6b20fd57]{width:100%;position:absolute;top:0;-webkit-transform:translateX(-100%);transform:translateX(-100%)}.yd-tab-panel-item.yd-tab-active[data-v-6b20fd57]{position:relative;-webkit-transition-timing-function:ease-in-out;transition-timing-function:ease-in-out;-webkit-transition:-webkit-transform .3s;transition:-webkit-transform .3s;transition:transform .3s;transition:transform .3s,-webkit-transform .3s;-webkit-transform:translateX(0);transform:translateX(0)}.yd-tab-panel-item.yd-tab-active~.yd-tab-panel-item[data-v-6b20fd57]{-webkit-transform:translateX(100%);transform:translateX(100%)}.scroll[data-v-6b20fd57]{position:relative}.scroll__graphic[data-v-6b20fd57]{position:-webkit-sticky;position:sticky;z-index:100;top:0;-webkit-transform:translateZ(0);transform:translateZ(0)}.yd-sticky-panel[data-v-6b20fd57]{position:relative}.sticky-nav[data-v-6b20fd57]{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;box-shadow:inset 2px 14px #888;-webkit-box-shadow:0 2px 14px #888;-moz-box-shadow:0 2px 14px #888}.sticky-nav .yd-tab-active[data-v-6b20fd57]{color:currentColor;background-color:#fff}.sticky-nav .yd-tab-active [data-v-6b20fd57]:before{content:\\\"\\\";width:70%;height:2px;position:absolute;left:50%;bottom:0;margin-left:-35%;z-index:4;background-color:currentColor}.sticky-nav .yd-tab-nav-item[data-v-6b20fd57]{font-size:16px;line-height:42px;-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1}.sticky-nav .yd-tab-nav-item[data-v-6b20fd57]:not(:last-child):after{display:none}.sticky-nav ul[data-v-6b20fd57]:after{content:\\\"\\\";width:100%;height:2px;position:absolute;left:0;bottom:0;z-index:4;background-color:currentColor}.yd-lyout-footer[data-v-6b20fd57]{position:fixed;bottom:0}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ }),\n\n/***/ 158:\n/***/ (function(module, exports) {\n\n\t/**\n\t * Copyright 2016 Google Inc. All Rights Reserved.\n\t *\n\t * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.\n\t *\n\t *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document\n\t *\n\t */\n\t\n\t(function(window, document) {\n\t'use strict';\n\t\n\t\n\t// Exits early if all IntersectionObserver and IntersectionObserverEntry\n\t// features are natively supported.\n\tif ('IntersectionObserver' in window &&\n\t    'IntersectionObserverEntry' in window &&\n\t    'intersectionRatio' in window.IntersectionObserverEntry.prototype) {\n\t\n\t  // Minimal polyfill for Edge 15's lack of `isIntersecting`\n\t  // See: https://github.com/w3c/IntersectionObserver/issues/211\n\t  if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {\n\t    Object.defineProperty(window.IntersectionObserverEntry.prototype,\n\t      'isIntersecting', {\n\t      get: function () {\n\t        return this.intersectionRatio > 0;\n\t      }\n\t    });\n\t  }\n\t  return;\n\t}\n\t\n\t\n\t/**\n\t * An IntersectionObserver registry. This registry exists to hold a strong\n\t * reference to IntersectionObserver instances currently observering a target\n\t * element. Without this registry, instances without another reference may be\n\t * garbage collected.\n\t */\n\tvar registry = [];\n\t\n\t\n\t/**\n\t * Creates the global IntersectionObserverEntry constructor.\n\t * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry\n\t * @param {Object} entry A dictionary of instance properties.\n\t * @constructor\n\t */\n\tfunction IntersectionObserverEntry(entry) {\n\t  this.time = entry.time;\n\t  this.target = entry.target;\n\t  this.rootBounds = entry.rootBounds;\n\t  this.boundingClientRect = entry.boundingClientRect;\n\t  this.intersectionRect = entry.intersectionRect || getEmptyRect();\n\t  this.isIntersecting = !!entry.intersectionRect;\n\t\n\t  // Calculates the intersection ratio.\n\t  var targetRect = this.boundingClientRect;\n\t  var targetArea = targetRect.width * targetRect.height;\n\t  var intersectionRect = this.intersectionRect;\n\t  var intersectionArea = intersectionRect.width * intersectionRect.height;\n\t\n\t  // Sets intersection ratio.\n\t  if (targetArea) {\n\t    this.intersectionRatio = intersectionArea / targetArea;\n\t  } else {\n\t    // If area is zero and is intersecting, sets to 1, otherwise to 0\n\t    this.intersectionRatio = this.isIntersecting ? 1 : 0;\n\t  }\n\t}\n\t\n\t\n\t/**\n\t * Creates the global IntersectionObserver constructor.\n\t * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface\n\t * @param {Function} callback The function to be invoked after intersection\n\t *     changes have queued. The function is not invoked if the queue has\n\t *     been emptied by calling the `takeRecords` method.\n\t * @param {Object=} opt_options Optional configuration options.\n\t * @constructor\n\t */\n\tfunction IntersectionObserver(callback, opt_options) {\n\t\n\t  var options = opt_options || {};\n\t\n\t  if (typeof callback != 'function') {\n\t    throw new Error('callback must be a function');\n\t  }\n\t\n\t  if (options.root && options.root.nodeType != 1) {\n\t    throw new Error('root must be an Element');\n\t  }\n\t\n\t  // Binds and throttles `this._checkForIntersections`.\n\t  this._checkForIntersections = throttle(\n\t      this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);\n\t\n\t  // Private properties.\n\t  this._callback = callback;\n\t  this._observationTargets = [];\n\t  this._queuedEntries = [];\n\t  this._rootMarginValues = this._parseRootMargin(options.rootMargin);\n\t\n\t  // Public properties.\n\t  this.thresholds = this._initThresholds(options.threshold);\n\t  this.root = options.root || null;\n\t  this.rootMargin = this._rootMarginValues.map(function(margin) {\n\t    return margin.value + margin.unit;\n\t  }).join(' ');\n\t}\n\t\n\t\n\t/**\n\t * The minimum interval within which the document will be checked for\n\t * intersection changes.\n\t */\n\tIntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;\n\t\n\t\n\t/**\n\t * The frequency in which the polyfill polls for intersection changes.\n\t * this can be updated on a per instance basis and must be set prior to\n\t * calling `observe` on the first target.\n\t */\n\tIntersectionObserver.prototype.POLL_INTERVAL = null;\n\t\n\t/**\n\t * Use a mutation observer on the root element\n\t * to detect intersection changes.\n\t */\n\tIntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;\n\t\n\t\n\t/**\n\t * Starts observing a target element for intersection changes based on\n\t * the thresholds values.\n\t * @param {Element} target The DOM element to observe.\n\t */\n\tIntersectionObserver.prototype.observe = function(target) {\n\t  var isTargetAlreadyObserved = this._observationTargets.some(function(item) {\n\t    return item.element == target;\n\t  });\n\t\n\t  if (isTargetAlreadyObserved) {\n\t    return;\n\t  }\n\t\n\t  if (!(target && target.nodeType == 1)) {\n\t    throw new Error('target must be an Element');\n\t  }\n\t\n\t  this._registerInstance();\n\t  this._observationTargets.push({element: target, entry: null});\n\t  this._monitorIntersections();\n\t  this._checkForIntersections();\n\t};\n\t\n\t\n\t/**\n\t * Stops observing a target element for intersection changes.\n\t * @param {Element} target The DOM element to observe.\n\t */\n\tIntersectionObserver.prototype.unobserve = function(target) {\n\t  this._observationTargets =\n\t      this._observationTargets.filter(function(item) {\n\t\n\t    return item.element != target;\n\t  });\n\t  if (!this._observationTargets.length) {\n\t    this._unmonitorIntersections();\n\t    this._unregisterInstance();\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * Stops observing all target elements for intersection changes.\n\t */\n\tIntersectionObserver.prototype.disconnect = function() {\n\t  this._observationTargets = [];\n\t  this._unmonitorIntersections();\n\t  this._unregisterInstance();\n\t};\n\t\n\t\n\t/**\n\t * Returns any queue entries that have not yet been reported to the\n\t * callback and clears the queue. This can be used in conjunction with the\n\t * callback to obtain the absolute most up-to-date intersection information.\n\t * @return {Array} The currently queued entries.\n\t */\n\tIntersectionObserver.prototype.takeRecords = function() {\n\t  var records = this._queuedEntries.slice();\n\t  this._queuedEntries = [];\n\t  return records;\n\t};\n\t\n\t\n\t/**\n\t * Accepts the threshold value from the user configuration object and\n\t * returns a sorted array of unique threshold values. If a value is not\n\t * between 0 and 1 and error is thrown.\n\t * @private\n\t * @param {Array|number=} opt_threshold An optional threshold value or\n\t *     a list of threshold values, defaulting to [0].\n\t * @return {Array} A sorted list of unique and valid threshold values.\n\t */\n\tIntersectionObserver.prototype._initThresholds = function(opt_threshold) {\n\t  var threshold = opt_threshold || [0];\n\t  if (!Array.isArray(threshold)) threshold = [threshold];\n\t\n\t  return threshold.sort().filter(function(t, i, a) {\n\t    if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {\n\t      throw new Error('threshold must be a number between 0 and 1 inclusively');\n\t    }\n\t    return t !== a[i - 1];\n\t  });\n\t};\n\t\n\t\n\t/**\n\t * Accepts the rootMargin value from the user configuration object\n\t * and returns an array of the four margin values as an object containing\n\t * the value and unit properties. If any of the values are not properly\n\t * formatted or use a unit other than px or %, and error is thrown.\n\t * @private\n\t * @param {string=} opt_rootMargin An optional rootMargin value,\n\t *     defaulting to '0px'.\n\t * @return {Array<Object>} An array of margin objects with the keys\n\t *     value and unit.\n\t */\n\tIntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {\n\t  var marginString = opt_rootMargin || '0px';\n\t  var margins = marginString.split(/\\s+/).map(function(margin) {\n\t    var parts = /^(-?\\d*\\.?\\d+)(px|%)$/.exec(margin);\n\t    if (!parts) {\n\t      throw new Error('rootMargin must be specified in pixels or percent');\n\t    }\n\t    return {value: parseFloat(parts[1]), unit: parts[2]};\n\t  });\n\t\n\t  // Handles shorthand.\n\t  margins[1] = margins[1] || margins[0];\n\t  margins[2] = margins[2] || margins[0];\n\t  margins[3] = margins[3] || margins[1];\n\t\n\t  return margins;\n\t};\n\t\n\t\n\t/**\n\t * Starts polling for intersection changes if the polling is not already\n\t * happening, and if the page's visibilty state is visible.\n\t * @private\n\t */\n\tIntersectionObserver.prototype._monitorIntersections = function() {\n\t  if (!this._monitoringIntersections) {\n\t    this._monitoringIntersections = true;\n\t\n\t    // If a poll interval is set, use polling instead of listening to\n\t    // resize and scroll events or DOM mutations.\n\t    if (this.POLL_INTERVAL) {\n\t      this._monitoringInterval = setInterval(\n\t          this._checkForIntersections, this.POLL_INTERVAL);\n\t    }\n\t    else {\n\t      addEvent(window, 'resize', this._checkForIntersections, true);\n\t      addEvent(document, 'scroll', this._checkForIntersections, true);\n\t\n\t      if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in window) {\n\t        this._domObserver = new MutationObserver(this._checkForIntersections);\n\t        this._domObserver.observe(document, {\n\t          attributes: true,\n\t          childList: true,\n\t          characterData: true,\n\t          subtree: true\n\t        });\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * Stops polling for intersection changes.\n\t * @private\n\t */\n\tIntersectionObserver.prototype._unmonitorIntersections = function() {\n\t  if (this._monitoringIntersections) {\n\t    this._monitoringIntersections = false;\n\t\n\t    clearInterval(this._monitoringInterval);\n\t    this._monitoringInterval = null;\n\t\n\t    removeEvent(window, 'resize', this._checkForIntersections, true);\n\t    removeEvent(document, 'scroll', this._checkForIntersections, true);\n\t\n\t    if (this._domObserver) {\n\t      this._domObserver.disconnect();\n\t      this._domObserver = null;\n\t    }\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * Scans each observation target for intersection changes and adds them\n\t * to the internal entries queue. If new entries are found, it\n\t * schedules the callback to be invoked.\n\t * @private\n\t */\n\tIntersectionObserver.prototype._checkForIntersections = function() {\n\t  var rootIsInDom = this._rootIsInDom();\n\t  var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();\n\t\n\t  this._observationTargets.forEach(function(item) {\n\t    var target = item.element;\n\t    var targetRect = getBoundingClientRect(target);\n\t    var rootContainsTarget = this._rootContainsTarget(target);\n\t    var oldEntry = item.entry;\n\t    var intersectionRect = rootIsInDom && rootContainsTarget &&\n\t        this._computeTargetAndRootIntersection(target, rootRect);\n\t\n\t    var newEntry = item.entry = new IntersectionObserverEntry({\n\t      time: now(),\n\t      target: target,\n\t      boundingClientRect: targetRect,\n\t      rootBounds: rootRect,\n\t      intersectionRect: intersectionRect\n\t    });\n\t\n\t    if (!oldEntry) {\n\t      this._queuedEntries.push(newEntry);\n\t    } else if (rootIsInDom && rootContainsTarget) {\n\t      // If the new entry intersection ratio has crossed any of the\n\t      // thresholds, add a new entry.\n\t      if (this._hasCrossedThreshold(oldEntry, newEntry)) {\n\t        this._queuedEntries.push(newEntry);\n\t      }\n\t    } else {\n\t      // If the root is not in the DOM or target is not contained within\n\t      // root but the previous entry for this target had an intersection,\n\t      // add a new record indicating removal.\n\t      if (oldEntry && oldEntry.isIntersecting) {\n\t        this._queuedEntries.push(newEntry);\n\t      }\n\t    }\n\t  }, this);\n\t\n\t  if (this._queuedEntries.length) {\n\t    this._callback(this.takeRecords(), this);\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * Accepts a target and root rect computes the intersection between then\n\t * following the algorithm in the spec.\n\t * TODO(philipwalton): at this time clip-path is not considered.\n\t * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo\n\t * @param {Element} target The target DOM element\n\t * @param {Object} rootRect The bounding rect of the root after being\n\t *     expanded by the rootMargin value.\n\t * @return {?Object} The final intersection rect object or undefined if no\n\t *     intersection is found.\n\t * @private\n\t */\n\tIntersectionObserver.prototype._computeTargetAndRootIntersection =\n\t    function(target, rootRect) {\n\t\n\t  // If the element isn't displayed, an intersection can't happen.\n\t  if (window.getComputedStyle(target).display == 'none') return;\n\t\n\t  var targetRect = getBoundingClientRect(target);\n\t  var intersectionRect = targetRect;\n\t  var parent = getParentNode(target);\n\t  var atRoot = false;\n\t\n\t  while (!atRoot) {\n\t    var parentRect = null;\n\t    var parentComputedStyle = parent.nodeType == 1 ?\n\t        window.getComputedStyle(parent) : {};\n\t\n\t    // If the parent isn't displayed, an intersection can't happen.\n\t    if (parentComputedStyle.display == 'none') return;\n\t\n\t    if (parent == this.root || parent == document) {\n\t      atRoot = true;\n\t      parentRect = rootRect;\n\t    } else {\n\t      // If the element has a non-visible overflow, and it's not the <body>\n\t      // or <html> element, update the intersection rect.\n\t      // Note: <body> and <html> cannot be clipped to a rect that's not also\n\t      // the document rect, so no need to compute a new intersection.\n\t      if (parent != document.body &&\n\t          parent != document.documentElement &&\n\t          parentComputedStyle.overflow != 'visible') {\n\t        parentRect = getBoundingClientRect(parent);\n\t      }\n\t    }\n\t\n\t    // If either of the above conditionals set a new parentRect,\n\t    // calculate new intersection data.\n\t    if (parentRect) {\n\t      intersectionRect = computeRectIntersection(parentRect, intersectionRect);\n\t\n\t      if (!intersectionRect) break;\n\t    }\n\t    parent = getParentNode(parent);\n\t  }\n\t  return intersectionRect;\n\t};\n\t\n\t\n\t/**\n\t * Returns the root rect after being expanded by the rootMargin value.\n\t * @return {Object} The expanded root rect.\n\t * @private\n\t */\n\tIntersectionObserver.prototype._getRootRect = function() {\n\t  var rootRect;\n\t  if (this.root) {\n\t    rootRect = getBoundingClientRect(this.root);\n\t  } else {\n\t    // Use <html>/<body> instead of window since scroll bars affect size.\n\t    var html = document.documentElement;\n\t    var body = document.body;\n\t    rootRect = {\n\t      top: 0,\n\t      left: 0,\n\t      right: html.clientWidth || body.clientWidth,\n\t      width: html.clientWidth || body.clientWidth,\n\t      bottom: html.clientHeight || body.clientHeight,\n\t      height: html.clientHeight || body.clientHeight\n\t    };\n\t  }\n\t  return this._expandRectByRootMargin(rootRect);\n\t};\n\t\n\t\n\t/**\n\t * Accepts a rect and expands it by the rootMargin value.\n\t * @param {Object} rect The rect object to expand.\n\t * @return {Object} The expanded rect.\n\t * @private\n\t */\n\tIntersectionObserver.prototype._expandRectByRootMargin = function(rect) {\n\t  var margins = this._rootMarginValues.map(function(margin, i) {\n\t    return margin.unit == 'px' ? margin.value :\n\t        margin.value * (i % 2 ? rect.width : rect.height) / 100;\n\t  });\n\t  var newRect = {\n\t    top: rect.top - margins[0],\n\t    right: rect.right + margins[1],\n\t    bottom: rect.bottom + margins[2],\n\t    left: rect.left - margins[3]\n\t  };\n\t  newRect.width = newRect.right - newRect.left;\n\t  newRect.height = newRect.bottom - newRect.top;\n\t\n\t  return newRect;\n\t};\n\t\n\t\n\t/**\n\t * Accepts an old and new entry and returns true if at least one of the\n\t * threshold values has been crossed.\n\t * @param {?IntersectionObserverEntry} oldEntry The previous entry for a\n\t *    particular target element or null if no previous entry exists.\n\t * @param {IntersectionObserverEntry} newEntry The current entry for a\n\t *    particular target element.\n\t * @return {boolean} Returns true if a any threshold has been crossed.\n\t * @private\n\t */\n\tIntersectionObserver.prototype._hasCrossedThreshold =\n\t    function(oldEntry, newEntry) {\n\t\n\t  // To make comparing easier, an entry that has a ratio of 0\n\t  // but does not actually intersect is given a value of -1\n\t  var oldRatio = oldEntry && oldEntry.isIntersecting ?\n\t      oldEntry.intersectionRatio || 0 : -1;\n\t  var newRatio = newEntry.isIntersecting ?\n\t      newEntry.intersectionRatio || 0 : -1;\n\t\n\t  // Ignore unchanged ratios\n\t  if (oldRatio === newRatio) return;\n\t\n\t  for (var i = 0; i < this.thresholds.length; i++) {\n\t    var threshold = this.thresholds[i];\n\t\n\t    // Return true if an entry matches a threshold or if the new ratio\n\t    // and the old ratio are on the opposite sides of a threshold.\n\t    if (threshold == oldRatio || threshold == newRatio ||\n\t        threshold < oldRatio !== threshold < newRatio) {\n\t      return true;\n\t    }\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * Returns whether or not the root element is an element and is in the DOM.\n\t * @return {boolean} True if the root element is an element and is in the DOM.\n\t * @private\n\t */\n\tIntersectionObserver.prototype._rootIsInDom = function() {\n\t  return !this.root || containsDeep(document, this.root);\n\t};\n\t\n\t\n\t/**\n\t * Returns whether or not the target element is a child of root.\n\t * @param {Element} target The target element to check.\n\t * @return {boolean} True if the target element is a child of root.\n\t * @private\n\t */\n\tIntersectionObserver.prototype._rootContainsTarget = function(target) {\n\t  return containsDeep(this.root || document, target);\n\t};\n\t\n\t\n\t/**\n\t * Adds the instance to the global IntersectionObserver registry if it isn't\n\t * already present.\n\t * @private\n\t */\n\tIntersectionObserver.prototype._registerInstance = function() {\n\t  if (registry.indexOf(this) < 0) {\n\t    registry.push(this);\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * Removes the instance from the global IntersectionObserver registry.\n\t * @private\n\t */\n\tIntersectionObserver.prototype._unregisterInstance = function() {\n\t  var index = registry.indexOf(this);\n\t  if (index != -1) registry.splice(index, 1);\n\t};\n\t\n\t\n\t/**\n\t * Returns the result of the performance.now() method or null in browsers\n\t * that don't support the API.\n\t * @return {number} The elapsed time since the page was requested.\n\t */\n\tfunction now() {\n\t  return window.performance && performance.now && performance.now();\n\t}\n\t\n\t\n\t/**\n\t * Throttles a function and delays its executiong, so it's only called at most\n\t * once within a given time period.\n\t * @param {Function} fn The function to throttle.\n\t * @param {number} timeout The amount of time that must pass before the\n\t *     function can be called again.\n\t * @return {Function} The throttled function.\n\t */\n\tfunction throttle(fn, timeout) {\n\t  var timer = null;\n\t  return function () {\n\t    if (!timer) {\n\t      timer = setTimeout(function() {\n\t        fn();\n\t        timer = null;\n\t      }, timeout);\n\t    }\n\t  };\n\t}\n\t\n\t\n\t/**\n\t * Adds an event handler to a DOM node ensuring cross-browser compatibility.\n\t * @param {Node} node The DOM node to add the event handler to.\n\t * @param {string} event The event name.\n\t * @param {Function} fn The event handler to add.\n\t * @param {boolean} opt_useCapture Optionally adds the even to the capture\n\t *     phase. Note: this only works in modern browsers.\n\t */\n\tfunction addEvent(node, event, fn, opt_useCapture) {\n\t  if (typeof node.addEventListener == 'function') {\n\t    node.addEventListener(event, fn, opt_useCapture || false);\n\t  }\n\t  else if (typeof node.attachEvent == 'function') {\n\t    node.attachEvent('on' + event, fn);\n\t  }\n\t}\n\t\n\t\n\t/**\n\t * Removes a previously added event handler from a DOM node.\n\t * @param {Node} node The DOM node to remove the event handler from.\n\t * @param {string} event The event name.\n\t * @param {Function} fn The event handler to remove.\n\t * @param {boolean} opt_useCapture If the event handler was added with this\n\t *     flag set to true, it should be set to true here in order to remove it.\n\t */\n\tfunction removeEvent(node, event, fn, opt_useCapture) {\n\t  if (typeof node.removeEventListener == 'function') {\n\t    node.removeEventListener(event, fn, opt_useCapture || false);\n\t  }\n\t  else if (typeof node.detatchEvent == 'function') {\n\t    node.detatchEvent('on' + event, fn);\n\t  }\n\t}\n\t\n\t\n\t/**\n\t * Returns the intersection between two rect objects.\n\t * @param {Object} rect1 The first rect.\n\t * @param {Object} rect2 The second rect.\n\t * @return {?Object} The intersection rect or undefined if no intersection\n\t *     is found.\n\t */\n\tfunction computeRectIntersection(rect1, rect2) {\n\t  var top = Math.max(rect1.top, rect2.top);\n\t  var bottom = Math.min(rect1.bottom, rect2.bottom);\n\t  var left = Math.max(rect1.left, rect2.left);\n\t  var right = Math.min(rect1.right, rect2.right);\n\t  var width = right - left;\n\t  var height = bottom - top;\n\t\n\t  return (width >= 0 && height >= 0) && {\n\t    top: top,\n\t    bottom: bottom,\n\t    left: left,\n\t    right: right,\n\t    width: width,\n\t    height: height\n\t  };\n\t}\n\t\n\t\n\t/**\n\t * Shims the native getBoundingClientRect for compatibility with older IE.\n\t * @param {Element} el The element whose bounding rect to get.\n\t * @return {Object} The (possibly shimmed) rect of the element.\n\t */\n\tfunction getBoundingClientRect(el) {\n\t  var rect;\n\t\n\t  try {\n\t    rect = el.getBoundingClientRect();\n\t  } catch (err) {\n\t    // Ignore Windows 7 IE11 \"Unspecified error\"\n\t    // https://github.com/w3c/IntersectionObserver/pull/205\n\t  }\n\t\n\t  if (!rect) return getEmptyRect();\n\t\n\t  // Older IE\n\t  if (!(rect.width && rect.height)) {\n\t    rect = {\n\t      top: rect.top,\n\t      right: rect.right,\n\t      bottom: rect.bottom,\n\t      left: rect.left,\n\t      width: rect.right - rect.left,\n\t      height: rect.bottom - rect.top\n\t    };\n\t  }\n\t  return rect;\n\t}\n\t\n\t\n\t/**\n\t * Returns an empty rect object. An empty rect is returned when an element\n\t * is not in the DOM.\n\t * @return {Object} The empty rect.\n\t */\n\tfunction getEmptyRect() {\n\t  return {\n\t    top: 0,\n\t    bottom: 0,\n\t    left: 0,\n\t    right: 0,\n\t    width: 0,\n\t    height: 0\n\t  };\n\t}\n\t\n\t/**\n\t * Checks to see if a parent element contains a child elemnt (including inside\n\t * shadow DOM).\n\t * @param {Node} parent The parent element.\n\t * @param {Node} child The child element.\n\t * @return {boolean} True if the parent node contains the child node.\n\t */\n\tfunction containsDeep(parent, child) {\n\t  var node = child;\n\t  while (node) {\n\t    if (node == parent) return true;\n\t\n\t    node = getParentNode(node);\n\t  }\n\t  return false;\n\t}\n\t\n\t\n\t/**\n\t * Gets the parent node of an element or its host element if the parent node\n\t * is a shadow root.\n\t * @param {Node} node The node whose parent to get.\n\t * @return {Node|null} The parent node or null if no parent exists.\n\t */\n\tfunction getParentNode(node) {\n\t  var parent = node.parentNode;\n\t\n\t  if (parent && parent.nodeType == 11 && parent.host) {\n\t    // If the parent is a shadow root, return the host element.\n\t    return parent.host;\n\t  }\n\t  return parent;\n\t}\n\t\n\t\n\t// Exposes the constructors globally.\n\twindow.IntersectionObserver = IntersectionObserver;\n\twindow.IntersectionObserverEntry = IntersectionObserverEntry;\n\t\n\t}(window, document));\n\n\n/***/ }),\n\n/***/ 159:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t(function (global, factory) {\n\t   true ? module.exports = factory() :\n\t  typeof define === 'function' && define.amd ? define(factory) :\n\t  (global.Jump = factory());\n\t}(this, (function () { 'use strict';\n\t\n\t// Robert Penner's easeInOutQuad\n\t\n\t// find the rest of his easing functions here: http://robertpenner.com/easing/\n\t// find them exported for ES6 consumption here: https://github.com/jaxgeller/ez.js\n\t\n\tvar easeInOutQuad = function easeInOutQuad(t, b, c, d) {\n\t  t /= d / 2;\n\t  if (t < 1) return c / 2 * t * t + b;\n\t  t--;\n\t  return -c / 2 * (t * (t - 2) - 1) + b;\n\t};\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n\t  return typeof obj;\n\t} : function (obj) {\n\t  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n\t};\n\t\n\tvar jumper = function jumper() {\n\t  // private variable cache\n\t  // no variables are created during a jump, preventing memory leaks\n\t\n\t  var element = void 0; // element to scroll to                   (node)\n\t\n\t  var start = void 0; // where scroll starts                    (px)\n\t  var stop = void 0; // where scroll stops                     (px)\n\t\n\t  var offset = void 0; // adjustment from the stop position      (px)\n\t  var easing = void 0; // easing function                        (function)\n\t  var a11y = void 0; // accessibility support flag             (boolean)\n\t\n\t  var distance = void 0; // distance of scroll                     (px)\n\t  var duration = void 0; // scroll duration                        (ms)\n\t\n\t  var timeStart = void 0; // time scroll started                    (ms)\n\t  var timeElapsed = void 0; // time spent scrolling thus far          (ms)\n\t\n\t  var next = void 0; // next scroll position                   (px)\n\t\n\t  var callback = void 0; // to call when done scrolling            (function)\n\t\n\t  // scroll position helper\n\t\n\t  function location() {\n\t    return window.scrollY || window.pageYOffset;\n\t  }\n\t\n\t  // element offset helper\n\t\n\t  function top(element) {\n\t    return element.getBoundingClientRect().top + start;\n\t  }\n\t\n\t  // rAF loop helper\n\t\n\t  function loop(timeCurrent) {\n\t    // store time scroll started, if not started already\n\t    if (!timeStart) {\n\t      timeStart = timeCurrent;\n\t    }\n\t\n\t    // determine time spent scrolling so far\n\t    timeElapsed = timeCurrent - timeStart;\n\t\n\t    // calculate next scroll position\n\t    next = easing(timeElapsed, start, distance, duration);\n\t\n\t    // scroll to it\n\t    window.scrollTo(0, next);\n\t\n\t    // check progress\n\t    timeElapsed < duration ? window.requestAnimationFrame(loop) // continue scroll loop\n\t    : done(); // scrolling is done\n\t  }\n\t\n\t  // scroll finished helper\n\t\n\t  function done() {\n\t    // account for rAF time rounding inaccuracies\n\t    window.scrollTo(0, start + distance);\n\t\n\t    // if scrolling to an element, and accessibility is enabled\n\t    if (element && a11y) {\n\t      // add tabindex indicating programmatic focus\n\t      element.setAttribute('tabindex', '-1');\n\t\n\t      // focus the element\n\t      element.focus();\n\t    }\n\t\n\t    // if it exists, fire the callback\n\t    if (typeof callback === 'function') {\n\t      callback();\n\t    }\n\t\n\t    // reset time for next jump\n\t    timeStart = false;\n\t  }\n\t\n\t  // API\n\t\n\t  function jump(target) {\n\t    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\n\t    // resolve options, or use defaults\n\t    duration = options.duration || 1000;\n\t    offset = options.offset || 0;\n\t    callback = options.callback; // \"undefined\" is a suitable default, and won't be called\n\t    easing = options.easing || easeInOutQuad;\n\t    a11y = options.a11y || false;\n\t\n\t    // cache starting position\n\t    start = location();\n\t\n\t    // resolve target\n\t    switch (typeof target === 'undefined' ? 'undefined' : _typeof(target)) {\n\t      // scroll from current position\n\t      case 'number':\n\t        element = undefined; // no element to scroll to\n\t        a11y = false; // make sure accessibility is off\n\t        stop = start + target;\n\t        break;\n\t\n\t      // scroll to element (node)\n\t      // bounding rect is relative to the viewport\n\t      case 'object':\n\t        element = target;\n\t        stop = top(element);\n\t        break;\n\t\n\t      // scroll to element (selector)\n\t      // bounding rect is relative to the viewport\n\t      case 'string':\n\t        element = document.querySelector(target);\n\t        stop = top(element);\n\t        break;\n\t    }\n\t\n\t    // resolve scroll distance, accounting for offset\n\t    distance = stop - start + offset;\n\t\n\t    // resolve duration\n\t    switch (_typeof(options.duration)) {\n\t      // number in ms\n\t      case 'number':\n\t        duration = options.duration;\n\t        break;\n\t\n\t      // function passed the distance of the scroll\n\t      case 'function':\n\t        duration = options.duration(distance);\n\t        break;\n\t    }\n\t\n\t    // start the loop\n\t    window.requestAnimationFrame(loop);\n\t  }\n\t\n\t  // expose only the jump method\n\t  return jump;\n\t};\n\t\n\t// export singleton\n\t\n\tvar singleton = jumper();\n\t\n\treturn singleton;\n\t\n\t})));\n\n\n/***/ }),\n\n/***/ 165:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t(function (global, factory) {\n\t\t true ? module.exports = factory() :\n\t\ttypeof define === 'function' && define.amd ? define(factory) :\n\t\t(global.scrollama = factory());\n\t}(this, (function () { 'use strict';\n\t\n\t// DOM helper functions\n\t\n\t// private\n\tfunction selectionToArray(selection) {\n\t  var len = selection.length;\n\t  var result = [];\n\t  for (var i = 0; i < len; i += 1) {\n\t    result.push(selection[i]);\n\t  }\n\t  return result;\n\t}\n\t\n\t// public\n\tfunction select(selector) {\n\t  if (selector instanceof Element) { return selector; }\n\t  else if (typeof selector === 'string')\n\t    { return document.querySelector(selector); }\n\t  return null;\n\t}\n\t\n\tfunction selectAll(selector, parent) {\n\t  if ( parent === void 0 ) parent = document;\n\t\n\t  if (typeof selector === 'string') {\n\t    return selectionToArray(parent.querySelectorAll(selector));\n\t  } else if (selector instanceof Element) {\n\t    return selectionToArray([selector]);\n\t  } else if (selector instanceof NodeList) {\n\t    return selectionToArray(selector);\n\t  } else if (selector instanceof Array) {\n\t    return selector;\n\t  }\n\t  return [];\n\t}\n\t\n\tfunction getStepId(ref) {\n\t  var id = ref.id;\n\t  var i = ref.i;\n\t\n\t  return (\"scrollama__debug-step--\" + id + \"-\" + i);\n\t}\n\t\n\tfunction getOffsetId(ref) {\n\t  var id = ref.id;\n\t\n\t  return (\"scrollama__debug-offset--\" + id);\n\t}\n\t\n\t// SETUP\n\t\n\tfunction setupOffset(ref) {\n\t  var id = ref.id;\n\t  var offsetVal = ref.offsetVal;\n\t  var stepClass = ref.stepClass;\n\t\n\t  var el = document.createElement('div');\n\t  el.setAttribute('id', getOffsetId({ id: id }));\n\t  el.setAttribute('class', 'scrollama__debug-offset');\n\t\n\t  el.style.position = 'fixed';\n\t  el.style.left = '0';\n\t  el.style.width = '100%';\n\t  el.style.height = '0px';\n\t  el.style.borderTop = '2px dashed black';\n\t  el.style.zIndex = '9999';\n\t\n\t  var text = document.createElement('p');\n\t  text.innerText = \"\\\".\" + stepClass + \"\\\" trigger: \" + offsetVal;\n\t  text.style.fontSize = '12px';\n\t  text.style.fontFamily = 'monospace';\n\t  text.style.color = 'black';\n\t  text.style.margin = '0';\n\t  text.style.padding = '6px';\n\t  el.appendChild(text);\n\t  document.body.appendChild(el);\n\t}\n\t\n\tfunction setup(ref) {\n\t  var id = ref.id;\n\t  var offsetVal = ref.offsetVal;\n\t  var stepEl = ref.stepEl;\n\t\n\t  var stepClass = stepEl[0].getAttribute('class');\n\t  setupOffset({ id: id, offsetVal: offsetVal, stepClass: stepClass });\n\t}\n\t\n\t// UPDATE\n\tfunction updateOffset(ref) {\n\t  var id = ref.id;\n\t  var offsetMargin = ref.offsetMargin;\n\t  var offsetVal = ref.offsetVal;\n\t\n\t  var idVal = getOffsetId({ id: id });\n\t  var el = document.querySelector((\"#\" + idVal));\n\t  el.style.top = offsetMargin + \"px\";\n\t}\n\t\n\tfunction update(ref) {\n\t  var id = ref.id;\n\t  var stepOffsetHeight = ref.stepOffsetHeight;\n\t  var offsetMargin = ref.offsetMargin;\n\t  var offsetVal = ref.offsetVal;\n\t\n\t  updateOffset({ id: id, offsetMargin: offsetMargin });\n\t}\n\t\n\tfunction notifyStep(ref) {\n\t  var id = ref.id;\n\t  var index = ref.index;\n\t  var state = ref.state;\n\t\n\t  var idVal = getStepId({ id: id, i: index });\n\t  var elA = document.querySelector((\"#\" + idVal + \"_above\"));\n\t  var elB = document.querySelector((\"#\" + idVal + \"_below\"));\n\t  var display = state === 'enter' ? 'block' : 'none';\n\t\n\t  if (elA) { elA.style.display = display; }\n\t  if (elB) { elB.style.display = display; }\n\t}\n\t\n\tfunction scrollama() {\n\t  var ZERO_MOE = 1; // zero with some rounding margin of error\n\t  var callback = {};\n\t  var io = {};\n\t\n\t  var containerEl = null;\n\t  var graphicEl = null;\n\t  var stepEl = null;\n\t\n\t  var id = null;\n\t  var offsetVal = 0;\n\t  var offsetMargin = 0;\n\t  var vh = 0;\n\t  var ph = 0;\n\t  var stepOffsetHeight = null;\n\t  var stepOffsetTop = null;\n\t  var bboxGraphic = null;\n\t\n\t  var isReady = false;\n\t  var isEnabled = false;\n\t  var debugMode = false;\n\t  var progressMode = false;\n\t  var progressThreshold = 0;\n\t  var preserveOrder = false;\n\t  var triggerOnce = false;\n\t\n\t  var stepStates = null;\n\t  var containerState = null;\n\t  var previousYOffset = -1;\n\t  var direction = null;\n\t\n\t  var exclude = [];\n\t\n\t  // HELPERS\n\t  function generateId() {\n\t    var a = 'abcdefghijklmnopqrstuv';\n\t    var l = a.length;\n\t    var t = new Date().getTime();\n\t    var r = [0, 0, 0].map(function (d) { return a[Math.floor(Math.random() * l)]; }).join('');\n\t    return (\"\" + r + t);\n\t  }\n\t\n\t  //www.gomakethings.com/how-to-get-an-elements-distance-from-the-top-of-the-page-with-vanilla-javascript/\n\t  function getOffsetTop(el) {\n\t    // Set our distance placeholder\n\t    var distance = 0;\n\t\n\t    // Loop up the DOM\n\t    if (el.offsetParent) {\n\t      do {\n\t        distance += el.offsetTop;\n\t        el = el.offsetParent;\n\t      } while (el);\n\t    }\n\t\n\t    // Return our distance\n\t    return distance < 0 ? 0 : distance;\n\t  }\n\t\n\t  function getPageHeight() {\n\t    var body = document.body;\n\t    var html = document.documentElement;\n\t\n\t    return Math.max(\n\t      body.scrollHeight,\n\t      body.offsetHeight,\n\t      html.clientHeight,\n\t      html.scrollHeight,\n\t      html.offsetHeight\n\t    );\n\t  }\n\t\n\t  function getIndex(element) {\n\t    return +element.getAttribute('data-scrollama-index');\n\t  }\n\t\n\t  function updateDirection() {\n\t    if (window.pageYOffset > previousYOffset) { direction = 'down'; }\n\t    else if (window.pageYOffset < previousYOffset) { direction = 'up'; }\n\t    previousYOffset = window.pageYOffset;\n\t  }\n\t\n\t  function handleResize() {\n\t    vh = window.innerHeight;\n\t    ph = getPageHeight();\n\t\n\t    bboxGraphic = graphicEl ? graphicEl.getBoundingClientRect() : null;\n\t\n\t    offsetMargin = offsetVal * vh;\n\t\n\t    stepOffsetHeight = stepEl ? stepEl.map(function (el) { return el.offsetHeight; }) : [];\n\t\n\t    stepOffsetTop = stepEl ? stepEl.map(getOffsetTop) : [];\n\t\n\t    if (isEnabled && isReady) { updateIO(); }\n\t\n\t    if (debugMode)\n\t      { update({ id: id, stepOffsetHeight: stepOffsetHeight, offsetMargin: offsetMargin, offsetVal: offsetVal }); }\n\t  }\n\t\n\t  function handleEnable(enable) {\n\t    if (enable && !isEnabled) {\n\t      if (isReady) { updateIO(); }\n\t      isEnabled = true;\n\t    } else if (!enable) {\n\t      if (io.top) { io.top.disconnect(); }\n\t      if (io.bottom) { io.bottom.disconnect(); }\n\t      if (io.stepAbove) { io.stepAbove.forEach(function (d) { return d.disconnect(); }); }\n\t      if (io.stepBelow) { io.stepBelow.forEach(function (d) { return d.disconnect(); }); }\n\t      if (io.stepProgress) { io.stepProgress.forEach(function (d) { return d.disconnect(); }); }\n\t      if (io.viewportAbove) { io.viewportAbove.forEach(function (d) { return d.disconnect(); }); }\n\t      if (io.viewportBelow) { io.viewportBelow.forEach(function (d) { return d.disconnect(); }); }\n\t      isEnabled = false;\n\t    }\n\t  }\n\t\n\t  function createThreshold(height) {\n\t    var count = Math.ceil(height / progressThreshold);\n\t    var t = [];\n\t    var ratio = 1 / count;\n\t    for (var i = 0; i < count; i++) {\n\t      t.push(i * ratio);\n\t    }\n\t    return t;\n\t  }\n\t\n\t  // NOTIFY CALLBACKS\n\t  function notifyOthers(index, location) {\n\t    if (location === 'above') {\n\t      // check if steps above/below were skipped and should be notified first\n\t      for (var i = 0; i < index; i++) {\n\t        var ss = stepStates[i];\n\t        if (ss.state === 'enter') { notifyStepExit(stepEl[i], 'down'); }\n\t        if (ss.direction === 'up') {\n\t          notifyStepEnter(stepEl[i], 'down', false);\n\t          notifyStepExit(stepEl[i], 'down');\n\t        }\n\t      }\n\t    } else if (location === 'below') {\n\t      for (var i$1 = stepStates.length - 1; i$1 > index; i$1--) {\n\t        var ss$1 = stepStates[i$1];\n\t        if (ss$1.state === 'enter') {\n\t          notifyStepExit(stepEl[i$1], 'up');\n\t        }\n\t        if (ss$1.direction === 'down') {\n\t          notifyStepEnter(stepEl[i$1], 'up', false);\n\t          notifyStepExit(stepEl[i$1], 'up');\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  function notifyStepEnter(element, direction, check) {\n\t    if ( check === void 0 ) check = true;\n\t\n\t    var index = getIndex(element);\n\t    var resp = { element: element, index: index, direction: direction };\n\t\n\t    // store most recent trigger\n\t    stepStates[index].direction = direction;\n\t    stepStates[index].state = 'enter';\n\t\n\t    if (preserveOrder && check && direction === 'down')\n\t      { notifyOthers(index, 'above'); }\n\t\n\t    if (preserveOrder && check && direction === 'up')\n\t      { notifyOthers(index, 'below'); }\n\t\n\t    if (\n\t      callback.stepEnter &&\n\t      typeof callback.stepEnter === 'function' &&\n\t      !exclude[index]\n\t    ) {\n\t      callback.stepEnter(resp, stepStates);\n\t      if (debugMode) { notifyStep({ id: id, index: index, state: 'enter' }); }\n\t      if (triggerOnce) { exclude[index] = true; }\n\t    }\n\t\n\t    if (progressMode) {\n\t      if (direction === 'down') { notifyStepProgress(element, 0); }\n\t      else { notifyStepProgress(element, 1); }\n\t    }\n\t  }\n\t\n\t  function notifyStepExit(element, direction) {\n\t    var index = getIndex(element);\n\t    var resp = { element: element, index: index, direction: direction };\n\t\n\t    // store most recent trigger\n\t    stepStates[index].direction = direction;\n\t    stepStates[index].state = 'exit';\n\t\n\t    if (progressMode) {\n\t      if (direction === 'down') { notifyStepProgress(element, 1); }\n\t      else { notifyStepProgress(element, 0); }\n\t    }\n\t\n\t    if (callback.stepExit && typeof callback.stepExit === 'function') {\n\t      callback.stepExit(resp, stepStates);\n\t      if (debugMode) { notifyStep({ id: id, index: index, state: 'exit' }); }\n\t    }\n\t  }\n\t\n\t  function notifyStepProgress(element, progress) {\n\t    var index = getIndex(element);\n\t    var resp = { element: element, index: index, progress: progress };\n\t    if (callback.stepProgress && typeof callback.stepProgress === 'function')\n\t      { callback.stepProgress(resp); }\n\t  }\n\t\n\t  function notifyContainerEnter() {\n\t    var resp = { direction: direction };\n\t    containerState.direction = direction;\n\t    containerState.state = 'enter';\n\t    if (\n\t      callback.containerEnter &&\n\t      typeof callback.containerEnter === 'function'\n\t    )\n\t      { callback.containerEnter(resp); }\n\t  }\n\t\n\t  function notifyContainerExit() {\n\t    var resp = { direction: direction };\n\t    containerState.direction = direction;\n\t    containerState.state = 'exit';\n\t    if (callback.containerExit && typeof callback.containerExit === 'function')\n\t      { callback.containerExit(resp); }\n\t  }\n\t\n\t  // OBSERVER - INTERSECT HANDLING\n\t\n\t  // if TOP edge of step crosses threshold,\n\t  // bottom must be > 0 which means it is on \"screen\" (shifted by offset)\n\t  function intersectStepAbove(entries) {\n\t    updateDirection();\n\t    entries.forEach(function (entry) {\n\t      var isIntersecting = entry.isIntersecting;\n\t      var boundingClientRect = entry.boundingClientRect;\n\t      var target = entry.target;\n\t\n\t      // bottom is how far bottom edge of el is from top of viewport\n\t      var bottom = boundingClientRect.bottom;\n\t      var height = boundingClientRect.height;\n\t      var bottomAdjusted = bottom - offsetMargin;\n\t      var index = getIndex(target);\n\t      var ss = stepStates[index];\n\t\n\t      if (bottomAdjusted >= -ZERO_MOE) {\n\t        if (isIntersecting && direction === 'down' && ss.state !== 'enter')\n\t          { notifyStepEnter(target, direction); }\n\t        else if (!isIntersecting && direction === 'up' && ss.state === 'enter')\n\t          { notifyStepExit(target, direction); }\n\t        else if (\n\t          !isIntersecting &&\n\t          bottomAdjusted >= height &&\n\t          direction === 'down' &&\n\t          ss.state === 'enter'\n\t        ) {\n\t          notifyStepExit(target, direction);\n\t        }\n\t      }\n\t    });\n\t  }\n\t\n\t  function intersectStepBelow(entries) {\n\t    updateDirection();\n\t    entries.forEach(function (entry) {\n\t      var isIntersecting = entry.isIntersecting;\n\t      var boundingClientRect = entry.boundingClientRect;\n\t      var target = entry.target;\n\t\n\t      var bottom = boundingClientRect.bottom;\n\t      var height = boundingClientRect.height;\n\t      var bottomAdjusted = bottom - offsetMargin;\n\t      var index = getIndex(target);\n\t      var ss = stepStates[index];\n\t\n\t      if (\n\t        bottomAdjusted >= -ZERO_MOE &&\n\t        bottomAdjusted < height &&\n\t        isIntersecting &&\n\t        direction === 'up' &&\n\t        ss.state !== 'enter'\n\t      ) {\n\t        notifyStepEnter(target, direction);\n\t      } else if (\n\t        bottomAdjusted <= ZERO_MOE &&\n\t        !isIntersecting &&\n\t        direction === 'down' &&\n\t        ss.state === 'enter'\n\t      ) {\n\t        notifyStepExit(target, direction);\n\t      }\n\t    });\n\t  }\n\t\n\t  /*\n\t\tif there is a scroll event where a step never intersects (therefore\n\t\tskipping an enter/exit trigger), use this fallback to detect if it is\n\t\tin view\n\t\t*/\n\t  function intersectViewportAbove(entries) {\n\t    updateDirection();\n\t    entries.forEach(function (entry) {\n\t      var isIntersecting = entry.isIntersecting;\n\t      var target = entry.target;\n\t      var index = getIndex(target);\n\t      var ss = stepStates[index];\n\t      if (\n\t        isIntersecting &&\n\t        direction === 'down' &&\n\t        ss.state !== 'enter' &&\n\t        ss.direction !== 'down'\n\t      ) {\n\t        notifyStepEnter(target, 'down');\n\t        notifyStepExit(target, 'down');\n\t      }\n\t    });\n\t  }\n\t\n\t  function intersectViewportBelow(entries) {\n\t    updateDirection();\n\t    entries.forEach(function (entry) {\n\t      var isIntersecting = entry.isIntersecting;\n\t      var target = entry.target;\n\t      var index = getIndex(target);\n\t      var ss = stepStates[index];\n\t      if (\n\t        isIntersecting &&\n\t        direction === 'up' &&\n\t        ss.state !== 'enter' &&\n\t        ss.direction !== 'up'\n\t      ) {\n\t        notifyStepEnter(target, 'up');\n\t        notifyStepExit(target, 'up');\n\t      }\n\t    });\n\t  }\n\t\n\t  function intersectStepProgress(entries) {\n\t    updateDirection();\n\t    entries.forEach(\n\t      function (ref) {\n\t        var isIntersecting = ref.isIntersecting;\n\t        var intersectionRatio = ref.intersectionRatio;\n\t        var boundingClientRect = ref.boundingClientRect;\n\t        var target = ref.target;\n\t\n\t        var bottom = boundingClientRect.bottom;\n\t        var bottomAdjusted = bottom - offsetMargin;\n\t\n\t        if (isIntersecting && bottomAdjusted >= -ZERO_MOE) {\n\t          notifyStepProgress(target, +intersectionRatio.toFixed(3));\n\t        }\n\t      }\n\t    );\n\t  }\n\t\n\t  function intersectTop(entries) {\n\t    updateDirection();\n\t    var ref = entries[0];\n\t    var isIntersecting = ref.isIntersecting;\n\t    var boundingClientRect = ref.boundingClientRect;\n\t    var top = boundingClientRect.top;\n\t    var bottom = boundingClientRect.bottom;\n\t\n\t    if (bottom > -ZERO_MOE) {\n\t      if (isIntersecting) { notifyContainerEnter(direction); }\n\t      else if (containerState.state === 'enter') { notifyContainerExit(direction); }\n\t    }\n\t  }\n\t\n\t  function intersectBottom(entries) {\n\t    updateDirection();\n\t    var ref = entries[0];\n\t    var isIntersecting = ref.isIntersecting;\n\t    var boundingClientRect = ref.boundingClientRect;\n\t    var top = boundingClientRect.top;\n\t\n\t    if (top < ZERO_MOE) {\n\t      if (isIntersecting) { notifyContainerEnter(direction); }\n\t      else if (containerState.state === 'enter') { notifyContainerExit(direction); }\n\t    }\n\t  }\n\t\n\t  // OBSERVER - CREATION\n\t\n\t  function updateTopIO() {\n\t    if (io.top) { io.top.unobserve(containerEl); }\n\t\n\t    var options = {\n\t      root: null,\n\t      rootMargin: (vh + \"px 0px -\" + vh + \"px 0px\"),\n\t      threshold: 0\n\t    };\n\t\n\t    io.top = new IntersectionObserver(intersectTop, options);\n\t    io.top.observe(containerEl);\n\t  }\n\t\n\t  function updateBottomIO() {\n\t    if (io.bottom) { io.bottom.unobserve(containerEl); }\n\t    var options = {\n\t      root: null,\n\t      rootMargin: (\"-\" + (bboxGraphic.height) + \"px 0px \" + (bboxGraphic.height) + \"px 0px\"),\n\t      threshold: 0\n\t    };\n\t\n\t    io.bottom = new IntersectionObserver(intersectBottom, options);\n\t    io.bottom.observe(containerEl);\n\t  }\n\t\n\t  // top edge\n\t  function updateStepAboveIO() {\n\t    if (io.stepAbove) { io.stepAbove.forEach(function (d) { return d.disconnect(); }); }\n\t\n\t    io.stepAbove = stepEl.map(function (el, i) {\n\t      var marginTop = stepOffsetHeight[i];\n\t      var marginBottom = -vh + offsetMargin;\n\t      var rootMargin = marginTop + \"px 0px \" + marginBottom + \"px 0px\";\n\t\n\t      var options = {\n\t        root: null,\n\t        rootMargin: rootMargin,\n\t        threshold: 0\n\t      };\n\t\n\t      var obs = new IntersectionObserver(intersectStepAbove, options);\n\t      obs.observe(el);\n\t      return obs;\n\t    });\n\t  }\n\t\n\t  // bottom edge\n\t  function updateStepBelowIO() {\n\t    if (io.stepBelow) { io.stepBelow.forEach(function (d) { return d.disconnect(); }); }\n\t\n\t    io.stepBelow = stepEl.map(function (el, i) {\n\t      var marginTop = -offsetMargin;\n\t      var marginBottom = ph - vh + stepOffsetHeight[i] + offsetMargin;\n\t      var rootMargin = marginTop + \"px 0px \" + marginBottom + \"px 0px\";\n\t\n\t      var options = {\n\t        root: null,\n\t        rootMargin: rootMargin,\n\t        threshold: 0\n\t      };\n\t\n\t      var obs = new IntersectionObserver(intersectStepBelow, options);\n\t      obs.observe(el);\n\t      return obs;\n\t    });\n\t  }\n\t\n\t  // jump into viewport\n\t  function updateViewportAboveIO() {\n\t    if (io.viewportAbove) { io.viewportAbove.forEach(function (d) { return d.disconnect(); }); }\n\t    io.viewportAbove = stepEl.map(function (el, i) {\n\t      var marginTop = stepOffsetTop[i];\n\t      var marginBottom = -(vh - offsetMargin + stepOffsetHeight[i]);\n\t      var rootMargin = marginTop + \"px 0px \" + marginBottom + \"px 0px\";\n\t      var options = {\n\t        root: null,\n\t        rootMargin: rootMargin,\n\t        threshold: 0\n\t      };\n\t\n\t      var obs = new IntersectionObserver(intersectViewportAbove, options);\n\t      obs.observe(el);\n\t      return obs;\n\t    });\n\t  }\n\t\n\t  function updateViewportBelowIO() {\n\t    if (io.viewportBelow) { io.viewportBelow.forEach(function (d) { return d.disconnect(); }); }\n\t    io.viewportBelow = stepEl.map(function (el, i) {\n\t      var marginTop = -(offsetMargin + stepOffsetHeight[i]);\n\t      var marginBottom =\n\t        ph - stepOffsetTop[i] - stepOffsetHeight[i] - offsetMargin;\n\t      var rootMargin = marginTop + \"px 0px \" + marginBottom + \"px 0px\";\n\t      var options = {\n\t        root: null,\n\t        rootMargin: rootMargin,\n\t        threshold: 0\n\t      };\n\t\n\t      var obs = new IntersectionObserver(intersectViewportBelow, options);\n\t      obs.observe(el);\n\t      return obs;\n\t    });\n\t  }\n\t\n\t  // progress progress tracker\n\t  function updateStepProgressIO() {\n\t    if (io.stepProgress) { io.stepProgress.forEach(function (d) { return d.disconnect(); }); }\n\t\n\t    io.stepProgress = stepEl.map(function (el, i) {\n\t      var marginTop = stepOffsetHeight[i] - offsetMargin;\n\t      var marginBottom = -vh + offsetMargin;\n\t      var rootMargin = marginTop + \"px 0px \" + marginBottom + \"px 0px\";\n\t\n\t      var threshold = createThreshold(stepOffsetHeight[i]);\n\t      var options = {\n\t        root: null,\n\t        rootMargin: rootMargin,\n\t        threshold: threshold\n\t      };\n\t\n\t      var obs = new IntersectionObserver(intersectStepProgress, options);\n\t      obs.observe(el);\n\t      return obs;\n\t    });\n\t  }\n\t\n\t  function updateIO() {\n\t    updateViewportAboveIO();\n\t    updateViewportBelowIO();\n\t    updateStepAboveIO();\n\t    updateStepBelowIO();\n\t\n\t    if (progressMode) { updateStepProgressIO(); }\n\t\n\t    if (containerEl && graphicEl) {\n\t      updateTopIO();\n\t      updateBottomIO();\n\t    }\n\t  }\n\t\n\t  // SETUP FUNCTIONS\n\t\n\t  function indexSteps() {\n\t    stepEl.forEach(function (el, i) { return el.setAttribute('data-scrollama-index', i); });\n\t  }\n\t\n\t  function setupStates() {\n\t    stepStates = stepEl.map(function () { return ({\n\t      direction: null,\n\t      state: null\n\t    }); });\n\t\n\t    containerState = { direction: null, state: null };\n\t  }\n\t\n\t  function addDebug() {\n\t    if (debugMode) { setup({ id: id, stepEl: stepEl, offsetVal: offsetVal }); }\n\t  }\n\t\n\t  var S = {};\n\t\n\t  S.setup = function (ref) {\n\t    var container = ref.container;\n\t    var graphic = ref.graphic;\n\t    var step = ref.step;\n\t    var offset = ref.offset; if ( offset === void 0 ) offset = 0.5;\n\t    var progress = ref.progress; if ( progress === void 0 ) progress = false;\n\t    var threshold = ref.threshold; if ( threshold === void 0 ) threshold = 4;\n\t    var debug = ref.debug; if ( debug === void 0 ) debug = false;\n\t    var order = ref.order; if ( order === void 0 ) order = true;\n\t    var once = ref.once; if ( once === void 0 ) once = false;\n\t\n\t    id = generateId();\n\t    // elements\n\t    stepEl = selectAll(step);\n\t    containerEl = container ? select(container) : null;\n\t    graphicEl = graphic ? select(graphic) : null;\n\t\n\t    // error if no step selected\n\t    if (!stepEl.length) {\n\t      console.error('scrollama error: no step elements');\n\t      return S;\n\t    }\n\t\n\t    // options\n\t    debugMode = debug;\n\t    progressMode = progress;\n\t    preserveOrder = order;\n\t    triggerOnce = once;\n\t\n\t    S.offsetTrigger(offset);\n\t    progressThreshold = Math.max(1, +threshold);\n\t\n\t    isReady = true;\n\t\n\t    // customize\n\t    addDebug();\n\t    indexSteps();\n\t    setupStates();\n\t    handleResize();\n\t    handleEnable(true);\n\t    return S;\n\t  };\n\t\n\t  S.resize = function () {\n\t    handleResize();\n\t    return S;\n\t  };\n\t\n\t  S.enable = function () {\n\t    handleEnable(true);\n\t    return S;\n\t  };\n\t\n\t  S.disable = function () {\n\t    handleEnable(false);\n\t    return S;\n\t  };\n\t\n\t  S.destroy = function () {\n\t    handleEnable(false);\n\t    Object.keys(callback).forEach(function (c) { return (callback[c] = null); });\n\t    Object.keys(io).forEach(function (i) { return (io[i] = null); });\n\t  };\n\t\n\t  S.offsetTrigger = function(x) {\n\t    if (x && !isNaN(x)) {\n\t      offsetVal = Math.min(Math.max(0, x), 1);\n\t      return S;\n\t    }\n\t    return offsetVal;\n\t  };\n\t\n\t  S.onStepEnter = function (cb) {\n\t    callback.stepEnter = cb;\n\t    return S;\n\t  };\n\t\n\t  S.onStepExit = function (cb) {\n\t    callback.stepExit = cb;\n\t    return S;\n\t  };\n\t\n\t  S.onStepProgress = function (cb) {\n\t    callback.stepProgress = cb;\n\t    return S;\n\t  };\n\t\n\t  S.onContainerEnter = function (cb) {\n\t    callback.containerEnter = cb;\n\t    return S;\n\t  };\n\t\n\t  S.onContainerExit = function (cb) {\n\t    callback.containerExit = cb;\n\t    return S;\n\t  };\n\t\n\t  return S;\n\t}\n\t\n\treturn scrollama;\n\t\n\t})));\n\n\n/***/ }),\n\n/***/ 166:\n/***/ (function(module, exports) {\n\n\t/*!\r\n\t  * Stickyfill – `position: sticky` polyfill\r\n\t  * v. 2.1.0 | https://github.com/wilddeer/stickyfill\r\n\t  * MIT License\r\n\t  */\r\n\t\r\n\t;(function(window, document) {\r\n\t    'use strict';\r\n\t    \r\n\t    /*\r\n\t     * 1. Check if the browser supports `position: sticky` natively or is too old to run the polyfill.\r\n\t     *    If either of these is the case set `seppuku` flag. It will be checked later to disable key features\r\n\t     *    of the polyfill, but the API will remain functional to avoid breaking things.\r\n\t     */\r\n\t    \r\n\t    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\r\n\t    \r\n\t    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\t    \r\n\t    var seppuku = false;\r\n\t    \r\n\t    var isWindowDefined = typeof window !== 'undefined';\r\n\t    \r\n\t    // The polyfill can’t function properly without `window` or `window.getComputedStyle`.\r\n\t    if (!isWindowDefined || !window.getComputedStyle) seppuku = true;\r\n\t    // Dont’t get in a way if the browser supports `position: sticky` natively.\r\n\t    else {\r\n\t            (function () {\r\n\t                var testNode = document.createElement('div');\r\n\t    \r\n\t                if (['', '-webkit-', '-moz-', '-ms-'].some(function (prefix) {\r\n\t                    try {\r\n\t                        testNode.style.position = prefix + 'sticky';\r\n\t                    } catch (e) {}\r\n\t    \r\n\t                    return testNode.style.position != '';\r\n\t                })) seppuku = true;\r\n\t            })();\r\n\t        }\r\n\t    \r\n\t    /*\r\n\t     * 2. “Global” vars used across the polyfill\r\n\t     */\r\n\t    var isInitialized = false;\r\n\t    \r\n\t    // Check if Shadow Root constructor exists to make further checks simpler\r\n\t    var shadowRootExists = typeof ShadowRoot !== 'undefined';\r\n\t    \r\n\t    // Last saved scroll position\r\n\t    var scroll = {\r\n\t        top: null,\r\n\t        left: null\r\n\t    };\r\n\t    \r\n\t    // Array of created Sticky instances\r\n\t    var stickies = [];\r\n\t    \r\n\t    /*\r\n\t     * 3. Utility functions\r\n\t     */\r\n\t    function extend(targetObj, sourceObject) {\r\n\t        for (var key in sourceObject) {\r\n\t            if (sourceObject.hasOwnProperty(key)) {\r\n\t                targetObj[key] = sourceObject[key];\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t    \r\n\t    function parseNumeric(val) {\r\n\t        return parseFloat(val) || 0;\r\n\t    }\r\n\t    \r\n\t    function getDocOffsetTop(node) {\r\n\t        var docOffsetTop = 0;\r\n\t    \r\n\t        while (node) {\r\n\t            docOffsetTop += node.offsetTop;\r\n\t            node = node.offsetParent;\r\n\t        }\r\n\t    \r\n\t        return docOffsetTop;\r\n\t    }\r\n\t    \r\n\t    /*\r\n\t     * 4. Sticky class\r\n\t     */\r\n\t    \r\n\t    var Sticky = function () {\r\n\t        function Sticky(node) {\r\n\t            _classCallCheck(this, Sticky);\r\n\t    \r\n\t            if (!(node instanceof HTMLElement)) throw new Error('First argument must be HTMLElement');\r\n\t            if (stickies.some(function (sticky) {\r\n\t                return sticky._node === node;\r\n\t            })) throw new Error('Stickyfill is already applied to this node');\r\n\t    \r\n\t            this._node = node;\r\n\t            this._stickyMode = null;\r\n\t            this._active = false;\r\n\t    \r\n\t            stickies.push(this);\r\n\t    \r\n\t            this.refresh();\r\n\t        }\r\n\t    \r\n\t        _createClass(Sticky, [{\r\n\t            key: 'refresh',\r\n\t            value: function refresh() {\r\n\t                if (seppuku || this._removed) return;\r\n\t                if (this._active) this._deactivate();\r\n\t    \r\n\t                var node = this._node;\r\n\t    \r\n\t                /*\r\n\t                 * 1. Save node computed props\r\n\t                 */\r\n\t                var nodeComputedStyle = getComputedStyle(node);\r\n\t                var nodeComputedProps = {\r\n\t                    position: nodeComputedStyle.position,\r\n\t                    top: nodeComputedStyle.top,\r\n\t                    display: nodeComputedStyle.display,\r\n\t                    marginTop: nodeComputedStyle.marginTop,\r\n\t                    marginBottom: nodeComputedStyle.marginBottom,\r\n\t                    marginLeft: nodeComputedStyle.marginLeft,\r\n\t                    marginRight: nodeComputedStyle.marginRight,\r\n\t                    cssFloat: nodeComputedStyle.cssFloat\r\n\t                };\r\n\t    \r\n\t                /*\r\n\t                 * 2. Check if the node can be activated\r\n\t                 */\r\n\t                if (isNaN(parseFloat(nodeComputedProps.top)) || nodeComputedProps.display == 'table-cell' || nodeComputedProps.display == 'none') return;\r\n\t    \r\n\t                this._active = true;\r\n\t    \r\n\t                /*\r\n\t                 * 3. Check if the current node position is `sticky`. If it is, it means that the browser supports sticky positioning,\r\n\t                 *    but the polyfill was force-enabled. We set the node’s position to `static` before continuing, so that the node\r\n\t                 *    is in it’s initial position when we gather its params.\r\n\t                 */\r\n\t                var originalPosition = node.style.position;\r\n\t                if (nodeComputedStyle.position == 'sticky' || nodeComputedStyle.position == '-webkit-sticky') node.style.position = 'static';\r\n\t    \r\n\t                /*\r\n\t                 * 4. Get necessary node parameters\r\n\t                 */\r\n\t                var referenceNode = node.parentNode;\r\n\t                var parentNode = shadowRootExists && referenceNode instanceof ShadowRoot ? referenceNode.host : referenceNode;\r\n\t                var nodeWinOffset = node.getBoundingClientRect();\r\n\t                var parentWinOffset = parentNode.getBoundingClientRect();\r\n\t                var parentComputedStyle = getComputedStyle(parentNode);\r\n\t    \r\n\t                this._parent = {\r\n\t                    node: parentNode,\r\n\t                    styles: {\r\n\t                        position: parentNode.style.position\r\n\t                    },\r\n\t                    offsetHeight: parentNode.offsetHeight\r\n\t                };\r\n\t                this._offsetToWindow = {\r\n\t                    left: nodeWinOffset.left,\r\n\t                    right: document.documentElement.clientWidth - nodeWinOffset.right\r\n\t                };\r\n\t                this._offsetToParent = {\r\n\t                    top: nodeWinOffset.top - parentWinOffset.top - parseNumeric(parentComputedStyle.borderTopWidth),\r\n\t                    left: nodeWinOffset.left - parentWinOffset.left - parseNumeric(parentComputedStyle.borderLeftWidth),\r\n\t                    right: -nodeWinOffset.right + parentWinOffset.right - parseNumeric(parentComputedStyle.borderRightWidth)\r\n\t                };\r\n\t                this._styles = {\r\n\t                    position: originalPosition,\r\n\t                    top: node.style.top,\r\n\t                    bottom: node.style.bottom,\r\n\t                    left: node.style.left,\r\n\t                    right: node.style.right,\r\n\t                    width: node.style.width,\r\n\t                    marginTop: node.style.marginTop,\r\n\t                    marginLeft: node.style.marginLeft,\r\n\t                    marginRight: node.style.marginRight\r\n\t                };\r\n\t    \r\n\t                var nodeTopValue = parseNumeric(nodeComputedProps.top);\r\n\t                this._limits = {\r\n\t                    start: nodeWinOffset.top + window.pageYOffset - nodeTopValue,\r\n\t                    end: parentWinOffset.top + window.pageYOffset + parentNode.offsetHeight - parseNumeric(parentComputedStyle.borderBottomWidth) - node.offsetHeight - nodeTopValue - parseNumeric(nodeComputedProps.marginBottom)\r\n\t                };\r\n\t    \r\n\t                /*\r\n\t                 * 5. Ensure that the node will be positioned relatively to the parent node\r\n\t                 */\r\n\t                var parentPosition = parentComputedStyle.position;\r\n\t    \r\n\t                if (parentPosition != 'absolute' && parentPosition != 'relative') {\r\n\t                    parentNode.style.position = 'relative';\r\n\t                }\r\n\t    \r\n\t                /*\r\n\t                 * 6. Recalc node position.\r\n\t                 *    It’s important to do this before clone injection to avoid scrolling bug in Chrome.\r\n\t                 */\r\n\t                this._recalcPosition();\r\n\t    \r\n\t                /*\r\n\t                 * 7. Create a clone\r\n\t                 */\r\n\t                var clone = this._clone = {};\r\n\t                clone.node = document.createElement('div');\r\n\t    \r\n\t                // Apply styles to the clone\r\n\t                extend(clone.node.style, {\r\n\t                    width: nodeWinOffset.right - nodeWinOffset.left + 'px',\r\n\t                    height: nodeWinOffset.bottom - nodeWinOffset.top + 'px',\r\n\t                    marginTop: nodeComputedProps.marginTop,\r\n\t                    marginBottom: nodeComputedProps.marginBottom,\r\n\t                    marginLeft: nodeComputedProps.marginLeft,\r\n\t                    marginRight: nodeComputedProps.marginRight,\r\n\t                    cssFloat: nodeComputedProps.cssFloat,\r\n\t                    padding: 0,\r\n\t                    border: 0,\r\n\t                    borderSpacing: 0,\r\n\t                    fontSize: '1em',\r\n\t                    position: 'static'\r\n\t                });\r\n\t    \r\n\t                referenceNode.insertBefore(clone.node, node);\r\n\t                clone.docOffsetTop = getDocOffsetTop(clone.node);\r\n\t            }\r\n\t        }, {\r\n\t            key: '_recalcPosition',\r\n\t            value: function _recalcPosition() {\r\n\t                if (!this._active || this._removed) return;\r\n\t    \r\n\t                var stickyMode = scroll.top <= this._limits.start ? 'start' : scroll.top >= this._limits.end ? 'end' : 'middle';\r\n\t    \r\n\t                if (this._stickyMode == stickyMode) return;\r\n\t    \r\n\t                switch (stickyMode) {\r\n\t                    case 'start':\r\n\t                        extend(this._node.style, {\r\n\t                            position: 'absolute',\r\n\t                            left: this._offsetToParent.left + 'px',\r\n\t                            right: this._offsetToParent.right + 'px',\r\n\t                            top: this._offsetToParent.top + 'px',\r\n\t                            bottom: 'auto',\r\n\t                            width: 'auto',\r\n\t                            marginLeft: 0,\r\n\t                            marginRight: 0,\r\n\t                            marginTop: 0\r\n\t                        });\r\n\t                        break;\r\n\t    \r\n\t                    case 'middle':\r\n\t                        extend(this._node.style, {\r\n\t                            position: 'fixed',\r\n\t                            left: this._offsetToWindow.left + 'px',\r\n\t                            right: this._offsetToWindow.right + 'px',\r\n\t                            top: this._styles.top,\r\n\t                            bottom: 'auto',\r\n\t                            width: 'auto',\r\n\t                            marginLeft: 0,\r\n\t                            marginRight: 0,\r\n\t                            marginTop: 0\r\n\t                        });\r\n\t                        break;\r\n\t    \r\n\t                    case 'end':\r\n\t                        extend(this._node.style, {\r\n\t                            position: 'absolute',\r\n\t                            left: this._offsetToParent.left + 'px',\r\n\t                            right: this._offsetToParent.right + 'px',\r\n\t                            top: 'auto',\r\n\t                            bottom: 0,\r\n\t                            width: 'auto',\r\n\t                            marginLeft: 0,\r\n\t                            marginRight: 0\r\n\t                        });\r\n\t                        break;\r\n\t                }\r\n\t    \r\n\t                this._stickyMode = stickyMode;\r\n\t            }\r\n\t        }, {\r\n\t            key: '_fastCheck',\r\n\t            value: function _fastCheck() {\r\n\t                if (!this._active || this._removed) return;\r\n\t    \r\n\t                if (Math.abs(getDocOffsetTop(this._clone.node) - this._clone.docOffsetTop) > 1 || Math.abs(this._parent.node.offsetHeight - this._parent.offsetHeight) > 1) this.refresh();\r\n\t            }\r\n\t        }, {\r\n\t            key: '_deactivate',\r\n\t            value: function _deactivate() {\r\n\t                var _this = this;\r\n\t    \r\n\t                if (!this._active || this._removed) return;\r\n\t    \r\n\t                this._clone.node.parentNode.removeChild(this._clone.node);\r\n\t                delete this._clone;\r\n\t    \r\n\t                extend(this._node.style, this._styles);\r\n\t                delete this._styles;\r\n\t    \r\n\t                // Check whether element’s parent node is used by other stickies.\r\n\t                // If not, restore parent node’s styles.\r\n\t                if (!stickies.some(function (sticky) {\r\n\t                    return sticky !== _this && sticky._parent && sticky._parent.node === _this._parent.node;\r\n\t                })) {\r\n\t                    extend(this._parent.node.style, this._parent.styles);\r\n\t                }\r\n\t                delete this._parent;\r\n\t    \r\n\t                this._stickyMode = null;\r\n\t                this._active = false;\r\n\t    \r\n\t                delete this._offsetToWindow;\r\n\t                delete this._offsetToParent;\r\n\t                delete this._limits;\r\n\t            }\r\n\t        }, {\r\n\t            key: 'remove',\r\n\t            value: function remove() {\r\n\t                var _this2 = this;\r\n\t    \r\n\t                this._deactivate();\r\n\t    \r\n\t                stickies.some(function (sticky, index) {\r\n\t                    if (sticky._node === _this2._node) {\r\n\t                        stickies.splice(index, 1);\r\n\t                        return true;\r\n\t                    }\r\n\t                });\r\n\t    \r\n\t                this._removed = true;\r\n\t            }\r\n\t        }]);\r\n\t    \r\n\t        return Sticky;\r\n\t    }();\r\n\t    \r\n\t    /*\r\n\t     * 5. Stickyfill API\r\n\t     */\r\n\t    \r\n\t    \r\n\t    var Stickyfill = {\r\n\t        stickies: stickies,\r\n\t        Sticky: Sticky,\r\n\t    \r\n\t        forceSticky: function forceSticky() {\r\n\t            seppuku = false;\r\n\t            init();\r\n\t    \r\n\t            this.refreshAll();\r\n\t        },\r\n\t        addOne: function addOne(node) {\r\n\t            // Check whether it’s a node\r\n\t            if (!(node instanceof HTMLElement)) {\r\n\t                // Maybe it’s a node list of some sort?\r\n\t                // Take first node from the list then\r\n\t                if (node.length && node[0]) node = node[0];else return;\r\n\t            }\r\n\t    \r\n\t            // Check if Stickyfill is already applied to the node\r\n\t            // and return existing sticky\r\n\t            for (var i = 0; i < stickies.length; i++) {\r\n\t                if (stickies[i]._node === node) return stickies[i];\r\n\t            }\r\n\t    \r\n\t            // Create and return new sticky\r\n\t            return new Sticky(node);\r\n\t        },\r\n\t        add: function add(nodeList) {\r\n\t            // If it’s a node make an array of one node\r\n\t            if (nodeList instanceof HTMLElement) nodeList = [nodeList];\r\n\t            // Check if the argument is an iterable of some sort\r\n\t            if (!nodeList.length) return;\r\n\t    \r\n\t            // Add every element as a sticky and return an array of created Sticky instances\r\n\t            var addedStickies = [];\r\n\t    \r\n\t            var _loop = function _loop(i) {\r\n\t                var node = nodeList[i];\r\n\t    \r\n\t                // If it’s not an HTMLElement – create an empty element to preserve 1-to-1\r\n\t                // correlation with input list\r\n\t                if (!(node instanceof HTMLElement)) {\r\n\t                    addedStickies.push(void 0);\r\n\t                    return 'continue';\r\n\t                }\r\n\t    \r\n\t                // If Stickyfill is already applied to the node\r\n\t                // add existing sticky\r\n\t                if (stickies.some(function (sticky) {\r\n\t                    if (sticky._node === node) {\r\n\t                        addedStickies.push(sticky);\r\n\t                        return true;\r\n\t                    }\r\n\t                })) return 'continue';\r\n\t    \r\n\t                // Create and add new sticky\r\n\t                addedStickies.push(new Sticky(node));\r\n\t            };\r\n\t    \r\n\t            for (var i = 0; i < nodeList.length; i++) {\r\n\t                var _ret2 = _loop(i);\r\n\t    \r\n\t                if (_ret2 === 'continue') continue;\r\n\t            }\r\n\t    \r\n\t            return addedStickies;\r\n\t        },\r\n\t        refreshAll: function refreshAll() {\r\n\t            stickies.forEach(function (sticky) {\r\n\t                return sticky.refresh();\r\n\t            });\r\n\t        },\r\n\t        removeOne: function removeOne(node) {\r\n\t            // Check whether it’s a node\r\n\t            if (!(node instanceof HTMLElement)) {\r\n\t                // Maybe it’s a node list of some sort?\r\n\t                // Take first node from the list then\r\n\t                if (node.length && node[0]) node = node[0];else return;\r\n\t            }\r\n\t    \r\n\t            // Remove the stickies bound to the nodes in the list\r\n\t            stickies.some(function (sticky) {\r\n\t                if (sticky._node === node) {\r\n\t                    sticky.remove();\r\n\t                    return true;\r\n\t                }\r\n\t            });\r\n\t        },\r\n\t        remove: function remove(nodeList) {\r\n\t            // If it’s a node make an array of one node\r\n\t            if (nodeList instanceof HTMLElement) nodeList = [nodeList];\r\n\t            // Check if the argument is an iterable of some sort\r\n\t            if (!nodeList.length) return;\r\n\t    \r\n\t            // Remove the stickies bound to the nodes in the list\r\n\t    \r\n\t            var _loop2 = function _loop2(i) {\r\n\t                var node = nodeList[i];\r\n\t    \r\n\t                stickies.some(function (sticky) {\r\n\t                    if (sticky._node === node) {\r\n\t                        sticky.remove();\r\n\t                        return true;\r\n\t                    }\r\n\t                });\r\n\t            };\r\n\t    \r\n\t            for (var i = 0; i < nodeList.length; i++) {\r\n\t                _loop2(i);\r\n\t            }\r\n\t        },\r\n\t        removeAll: function removeAll() {\r\n\t            while (stickies.length) {\r\n\t                stickies[0].remove();\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t    \r\n\t    /*\r\n\t     * 6. Setup events (unless the polyfill was disabled)\r\n\t     */\r\n\t    function init() {\r\n\t        if (isInitialized) {\r\n\t            return;\r\n\t        }\r\n\t    \r\n\t        isInitialized = true;\r\n\t    \r\n\t        // Watch for scroll position changes and trigger recalc/refresh if needed\r\n\t        function checkScroll() {\r\n\t            if (window.pageXOffset != scroll.left) {\r\n\t                scroll.top = window.pageYOffset;\r\n\t                scroll.left = window.pageXOffset;\r\n\t    \r\n\t                Stickyfill.refreshAll();\r\n\t            } else if (window.pageYOffset != scroll.top) {\r\n\t                scroll.top = window.pageYOffset;\r\n\t                scroll.left = window.pageXOffset;\r\n\t    \r\n\t                // recalc position for all stickies\r\n\t                stickies.forEach(function (sticky) {\r\n\t                    return sticky._recalcPosition();\r\n\t                });\r\n\t            }\r\n\t        }\r\n\t    \r\n\t        checkScroll();\r\n\t        window.addEventListener('scroll', checkScroll);\r\n\t    \r\n\t        // Watch for window resizes and device orientation changes and trigger refresh\r\n\t        window.addEventListener('resize', Stickyfill.refreshAll);\r\n\t        window.addEventListener('orientationchange', Stickyfill.refreshAll);\r\n\t    \r\n\t        //Fast dirty check for layout changes every 500ms\r\n\t        var fastCheckTimer = void 0;\r\n\t    \r\n\t        function startFastCheckTimer() {\r\n\t            fastCheckTimer = setInterval(function () {\r\n\t                stickies.forEach(function (sticky) {\r\n\t                    return sticky._fastCheck();\r\n\t                });\r\n\t            }, 500);\r\n\t        }\r\n\t    \r\n\t        function stopFastCheckTimer() {\r\n\t            clearInterval(fastCheckTimer);\r\n\t        }\r\n\t    \r\n\t        var docHiddenKey = void 0;\r\n\t        var visibilityChangeEventName = void 0;\r\n\t    \r\n\t        if ('hidden' in document) {\r\n\t            docHiddenKey = 'hidden';\r\n\t            visibilityChangeEventName = 'visibilitychange';\r\n\t        } else if ('webkitHidden' in document) {\r\n\t            docHiddenKey = 'webkitHidden';\r\n\t            visibilityChangeEventName = 'webkitvisibilitychange';\r\n\t        }\r\n\t    \r\n\t        if (visibilityChangeEventName) {\r\n\t            if (!document[docHiddenKey]) startFastCheckTimer();\r\n\t    \r\n\t            document.addEventListener(visibilityChangeEventName, function () {\r\n\t                if (document[docHiddenKey]) {\r\n\t                    stopFastCheckTimer();\r\n\t                } else {\r\n\t                    startFastCheckTimer();\r\n\t                }\r\n\t            });\r\n\t        } else startFastCheckTimer();\r\n\t    }\r\n\t    \r\n\t    if (!seppuku) init();\r\n\t    \r\n\t    /*\r\n\t     * 7. Expose Stickyfill\r\n\t     */\r\n\t    if (typeof module != 'undefined' && module.exports) {\r\n\t        module.exports = Stickyfill;\r\n\t    } else if (isWindowDefined) {\r\n\t        window.Stickyfill = Stickyfill;\r\n\t    }\r\n\t    \r\n\t})(window, document);\n\n/***/ }),\n\n/***/ 232:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Component = __webpack_require__(1)(\n\t  /* script */\n\t  __webpack_require__(99),\n\t  /* template */\n\t  __webpack_require__(250),\n\t  /* scopeId */\n\t  null,\n\t  /* cssModules */\n\t  null\n\t)\n\t\n\tmodule.exports = Component.exports\n\n\n/***/ }),\n\n/***/ 233:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\n\t/* styles */\n\t__webpack_require__(341)\n\t\n\tvar Component = __webpack_require__(1)(\n\t  /* script */\n\t  __webpack_require__(100),\n\t  /* template */\n\t  __webpack_require__(290),\n\t  /* scopeId */\n\t  \"data-v-6b20fd57\",\n\t  /* cssModules */\n\t  null\n\t)\n\t\n\tmodule.exports = Component.exports\n\n\n/***/ }),\n\n/***/ 250:\n/***/ (function(module, exports) {\n\n\tmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n\t  return _c('div', {\n\t    staticClass: \"step\",\n\t    class: _vm.classes\n\t  }, [_vm._t(\"default\")], 2)\n\t},staticRenderFns: []}\n\n/***/ }),\n\n/***/ 290:\n/***/ (function(module, exports) {\n\n\tmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n\t  return _c('div', {\n\t    ref: \"wrapper\",\n\t    staticClass: \"wrapper\"\n\t  }, [_c('div', {\n\t    ref: \"banner\"\n\t  }, [_vm._t(\"banner\")], 2), _vm._v(\" \"), _c('div', {\n\t    staticClass: \"scroll\"\n\t  }, [_c('div', {\n\t    ref: \"stickyNav\",\n\t    staticClass: \"scroll__graphic\"\n\t  }, [_c('ul', {\n\t    directives: [{\n\t      name: \"show\",\n\t      rawName: \"v-show\",\n\t      value: (_vm.navList.length > 0),\n\t      expression: \"navList.length > 0\"\n\t    }],\n\t    staticClass: \"sticky-nav\",\n\t    style: ({\n\t      color: _vm.activeColor\n\t    })\n\t  }, _vm._l((_vm.navList), function(item, key) {\n\t    return _c('li', {\n\t      key: key,\n\t      staticClass: \"yd-tab-nav-item\",\n\t      class: item._uid == _vm.activeIndex ? 'yd-tab-active' : '',\n\t      on: {\n\t        \"click\": function($event) {\n\t          _vm.changeHandler(item._uid, item.label, item.tabkey, item.panel, key)\n\t        }\n\t      }\n\t    }, [_c('a', {\n\t      attrs: {\n\t        \"href\": \"javascript:;\"\n\t      }\n\t    }, [_vm._v(_vm._s(item.label))])])\n\t  }))]), _vm._v(\" \"), _c('div', {\n\t    ref: \"panel\",\n\t    staticClass: \"yd-sticky-panel\"\n\t  }, [_vm._t(\"default\")], 2)]), _vm._v(\" \"), _c('div', {\n\t    staticClass: \"yd-lyout-footer\"\n\t  }, [_vm._t(\"footer\")], 2)])\n\t},staticRenderFns: []}\n\n/***/ }),\n\n/***/ 341:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(140);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\tif(content.locals) module.exports = content.locals;\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(3)(\"605ef899\", content, true);\n\n/***/ })\n\n/******/ })\n});\n;\n\n\n// WEBPACK FOOTER //\n// /lib.rem/stickynav/index.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 724a6030bf776d82d1c1","import StickyNav from './src/stickynav.vue';\nimport StickyPanel from './src/sticky-panel.vue';\nexport { StickyNav ,StickyPanel};\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/stickynav/index.js","module.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  scopeId,\n  cssModules\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  // inject cssModules\n  if (cssModules) {\n    var computed = options.computed || (options.computed = {})\n    Object.keys(cssModules).forEach(function (key) {\n      var module = cssModules[key]\n      computed[key] = function () { return module }\n    })\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_vue-loader@10.3.0@vue-loader/lib/component-normalizer.js\n// module id = 1\n// module chunks = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function() {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\tvar result = [];\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar item = this[i];\n\t\t\tif(item[2]) {\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\n\t\t\t} else {\n\t\t\t\tresult.push(item[1]);\n\t\t\t}\n\t\t}\n\t\treturn result.join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_css-loader@0.26.4@css-loader/lib/css-base.js\n// module id = 2\n// module chunks = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40","/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\nvar listToStyles = require('./listToStyles')\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nmodule.exports = function (parentId, list, _isProduction) {\n  isProduction = _isProduction\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[data-vue-ssr-id~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_vue-style-loader@2.0.5@vue-style-loader/lib/addStylesClient.js\n// module id = 3\n// module chunks = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40","/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nmodule.exports = function listToStyles (parentId, list) {\n  var styles = []\n  var newStyles = {}\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i]\n    var id = item[0]\n    var css = item[1]\n    var media = item[2]\n    var sourceMap = item[3]\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    }\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] })\n    } else {\n      newStyles[id].parts.push(part)\n    }\n  }\n  return styles\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_vue-style-loader@2.0.5@vue-style-loader/lib/listToStyles.js\n// module id = 4\n// module chunks = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40","const pageScroll = (function () {\n    const fn = function (e) {\n        e.preventDefault();\n        e.stopPropagation();\n    };\n    let islock = false;\n\n    return {\n        lock(el) {\n            if (islock) return;\n            islock = true;\n            (el || document).addEventListener('touchmove', fn);\n        },\n        unlock(el) {\n            islock = false;\n            (el || document).removeEventListener('touchmove', fn);\n        }\n    };\n})();\n\nconst preventScroll = (function (bodyCls) {\n    let scrollTop;\n    return {\n        lock() {\n            scrollTop = document.scrollingElement.scrollTop;\n            document.body.classList.add(bodyCls);\n            document.body.style.top = -scrollTop + 'px';\n        },\n        unlock() {\n            document.body.classList.remove(bodyCls);\n            document.scrollingElement.scrollTop = scrollTop;\n        }\n    };\n})('g-fix-ios-prevent-scroll');\n//此方法完美解决滚动穿透问题\n\nconst isIOS = !!(window.navigator && window.navigator.userAgent || '').match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/);\n\nconst isColor = function (value) {\n    const colorReg = /^#([a-fA-F0-9]){3}(([a-fA-F0-9]){3})?$/;\n    const rgbaReg = /^[rR][gG][bB][aA]\\(\\s*((25[0-5]|2[0-4]\\d|1?\\d{1,2})\\s*,\\s*){3}\\s*(\\.|\\d+\\.)?\\d+\\s*\\)$/;\n    const rgbReg = /^[rR][gG][bB]\\(\\s*((25[0-5]|2[0-4]\\d|1?\\d{1,2})\\s*,\\s*){2}(25[0-5]|2[0-4]\\d|1?\\d{1,2})\\s*\\)$/;\n\n    return colorReg.test(value) || rgbaReg.test(value) || rgbReg.test(value);\n};\nconst getPos=function(ele){\n    let t = ele.offsetTop;\n    while (ele = ele.offsetParent) {\n        t += ele.offsetTop;\n    }\n    return t;\n}\n\nconst getScrollview = function (el) {\n    let currentNode = el;\n    while (currentNode && currentNode.tagName !== 'HTML' && currentNode.tagName !== 'BODY' && currentNode.nodeType === 1) {\n        let overflowY = document.defaultView.getComputedStyle(currentNode).overflowY;\n        if (overflowY === 'scroll' || overflowY === 'auto') {\n            return currentNode;\n        }\n        currentNode = currentNode.parentNode;\n    }\n    return window;\n};\n\nconst checkInview = function (scrollView, el) {\n    const contentHeight = scrollView === window ? document.body.offsetHeight : scrollView.offsetHeight;\n    const contentTop = scrollView === window ? 0 : scrollView.getBoundingClientRect().top;\n\n    const post = el.getBoundingClientRect().top - contentTop;\n    const posb = post + el.offsetHeight;\n\n    return (post >= 0 && post < contentHeight) || (posb > 0 && posb <= contentHeight);\n};\n\nconst hasClass = function (elem, cls) {\n    cls = cls || '';\n    if (cls.replace(/\\s/g, '').length === 0 || !elem) return false;\n    return new RegExp(' ' + cls + ' ').test(' ' + elem.className + ' ');\n};\n\nconst addClass = function (ele, cls) {\n    if (!hasClass(ele, cls)) {\n        ele.className = ele.className === '' ? cls : ele.className + ' ' + cls;\n    }\n};\n\nconst removeClass = function (ele, cls) {\n    if (hasClass(ele, cls)) {\n        let newClass = ' ' + ele.className.replace(/[\\t\\r\\n]/g, '') + ' ';\n        while (newClass.indexOf(' ' + cls + ' ') >= 0) {\n            newClass = newClass.replace(' ' + cls + ' ', ' ');\n        }\n        ele.className = newClass.replace(/^\\s+|\\s+$/g, '');\n    }\n};\n\n//Copy from iView. https://www.iviewui.com/\nconst scrollTop = function (el, from = 0, to, duration = 500, callback) {\n    if (!window.requestAnimationFrame) {\n        window.requestAnimationFrame = (\n            window.webkitRequestAnimationFrame ||\n            window.mozRequestAnimationFrame ||\n            window.msRequestAnimationFrame ||\n            function (callback) {\n                return window.setTimeout(callback, 1000 / 60);\n            }\n        );\n    }\n    const difference = Math.abs(from - to);\n    const step = Math.ceil(difference / duration * 50);\n\n    function scroll(start, end, step) {\n        if (start === end) {\n            typeof callback === 'function' && callback();\n            return;\n        }\n\n        let d = (start + step > end) ? end : start + step;\n        if (start > end) {\n            d = (start - step < end) ? end : start - step;\n        }\n\n        if (el === window) {\n            window.scrollTo(d, d);\n        } else {\n            el.scrollTop = d;\n        }\n        window.requestAnimationFrame(() => scroll(d, end, step));\n    }\n\n    scroll(from, to, step);\n};\n\nexport {pageScroll, preventScroll, isIOS, isColor,getPos, getScrollview, checkInview, addClass, removeClass, scrollTop};\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/assist.js","<template>\n    <div class=\"step\" :class=\"classes\">\n        <slot></slot>\n    </div>\n</template>\n\n<script type=\"text/babel\">\n    export default {\n        name: 'yd-sticky-panel',\n        data() {\n            return {\n                isCurrent: false\n            }\n        },\n        props: {\n            label: String,\n            active: Boolean,\n            tabkey: [String, Number]\n        },\n        computed: {\n            classes() {\n                return this.$parent.activeIndex === this._uid || this.isCurrent ? 'yd-tab-active' : '';\n            }\n        },\n        watch: {\n            active() {\n                this.$parent.init();\n            },\n            label() {\n                this.$parent.init();\n            }\n        },\n        mounted() {\n            this.$nextTick(() => {\n                this.$parent.init();\n            });\n        }\n    }\n</script>\n\n\n\n// WEBPACK FOOTER //\n// sticky-panel.vue?0adeeb4a","<template>\n    <div class=\"wrapper\" ref=\"wrapper\">\n        <div ref=\"banner\">\n            <slot name=\"banner\"></slot>\n        </div>\n        <div class=\"scroll\">\n            <div ref=\"stickyNav\" class=\"scroll__graphic\">\n                <ul class=\"sticky-nav\" :style=\"{color: activeColor}\" v-show=\"navList.length > 0\">\n                    <li class=\"yd-tab-nav-item\"\n                        v-for=\"item, key in navList\"\n                        :key=\"key\"\n                        :class=\"item._uid == activeIndex ? 'yd-tab-active' : ''\"\n                        @click=\"changeHandler(item._uid, item.label, item.tabkey,item.panel,key)\">\n                        <a href=\"javascript:;\">{{item.label}}</a>\n                    </li>\n                </ul>\n            </div>\n            <div class=\"yd-sticky-panel\" ref=\"panel\">\n                <slot></slot>\n            </div>\n        </div>\n        <div class=\"yd-lyout-footer\">\n            <slot name=\"footer\"></slot>\n        </div>\n\n    </div>\n</template>\n<script>\n    import 'intersection-observer';\n    import 'stickyfilljs'\n    import scrollama from 'scrollama';\n    import {isColor} from '../../../utils/assist';\n    import jump from 'jump.js'\n    export default {\n        name: \"yd-sticky-nav\",\n        data() {\n            return {\n                currentKey: '',\n                navList: [],\n                activeIndex: 0,\n                tmpIndex: 0,\n                tabPanels: []\n            };\n        },\n        props: {\n            change: Function,\n            callback: Function,\n            activeColor: {\n                validator(value) {\n                    if (!value) return true;\n                    return isColor(value);\n                },\n                default: '#005bac'\n            },\n            offset: {\n                type: Number,\n                default: 0\n            }\n        },\n        methods: {\n            emitChange(label, tabkey) {\n                this.callback && this.callback(label, tabkey);\n            },\n            changeHandler(uid, label, tabkey, panel, index) {\n                if (this.tmpIndex != uid) {\n                    this.activeIndex = this.tmpIndex = uid;\n                    this.emitChange(label, tabkey);\n                }\n                jump(panel.$el, {offset: -this.navOffSet, duration: 400})\n            },\n\n            handleStepEnter(response) {\n                this.activeIndex = this.navList[response.index]._uid;\n            },\n            init() {\n                const topHeigth = 0;//this.$refs.banner.offsetHeight+this.$refs.stickyNav.offsetHeight\n                const tabPanels = this.$children.filter(item => item.$options.name === 'yd-sticky-panel');\n                this.navList = [];\n                const panelList = [];\n                tabPanels.forEach((panel, index) => {\n                    this.navList.push({\n                        _uid: panel._uid,\n                        label: panel.label,\n                        tabkey: panel.tabkey,\n                        panel: panel\n                    });\n                    panelList.push(panel.$el)\n                });\n                if (!this.scroller) {\n                    this.scroller = scrollama();\n                    this.scroller.setup({\n                        container: '.scroll', // required (for sticky)\n                        graphic: '.scroll__graphic', // required (for sticky)\n                        text: '.scroll__text',\n                        step: panelList,\n                        offset: 0.33\n                    })\n                            .onStepEnter(this.handleStepEnter)\n                    this.$nextTick(() => {\n                        window.addEventListener('resize', this.resizeHandler);\n                        this.navOffSet = this.$refs['stickyNav'].offsetHeight + this.offset\n                    })\n                }\n\n            },\n            resizeHandler() {\n                console.log(\"窗口重置\")\n                this.scroller.resize()\n            }\n        },\n        mounted() {\n\n        },\n        created() {\n            this.inited = false;\n            this.scroller;\n            this.navOffSet = this.offset;\n        }\n    };\n\n</script>\n<style lang=\"less\" scoped>\n    @import \"../../../styles/components/tab.less\";\n    .scroll {\n        position: relative;\n    }\n\n    .scroll__graphic {\n        position: -webkit-sticky;\n        position: sticky;\n        z-index: 100;\n        top: 0;\n        -webkit-transform: translate3d(0, 0, 0);\n        -moz-transform: translate3d(0, 0, 0);\n        transform: translate3d(0, 0, 0);\n    }\n\n    .yd-sticky-panel {\n        position: relative;\n    }\n    .sticky-nav {\n        display: flex;\n        box-shadow: inset 2px 14px #888;\n        -webkit-box-shadow:0 2px 14px #888;\n        -moz-box-shadow:0 2px 14px #888;\n        .yd-tab-active{\n            color: currentColor;\n            background-color: #FFF;\n            :before{\n                content: '';\n                width: 70%;\n                height: 2px;\n                position: absolute;\n                left: 50%;\n                bottom: 0;\n                margin-left: -35%;\n                z-index: 4;\n                background-color: currentColor;\n            }\n        }\n        .yd-tab-nav-item {\n            font-size: 16px;\n            line-height: 42px;\n            flex: 1;\n            &:not(:last-child):after{\n                display: none;\n            }\n        }\n        ul::after{\n            content: '';\n            width: 100%;\n            height: 2px;\n            position: absolute;\n            left: 0;\n            bottom: 0;\n            z-index: 4;\n            background-color: currentColor;\n        }\n    }\n    .yd-lyout-footer{\n        position: fixed;\n        bottom: 0;\n    }\n</style>\n\n\n\n// WEBPACK FOOTER //\n// stickynav.vue?882253d0","exports = module.exports = require(\"../../../../node_modules/_css-loader@0.26.4@css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".yd-tab-box[data-v-6b20fd57]{overflow:auto;-webkit-overflow-scrolling:touch;background-color:#fff}.yd-tab-nav-nomal .yd-tab-nav[data-v-6b20fd57]{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap}.yd-tab-nav-nomal .yd-tab-nav .yd-tab-nav-item[data-v-6b20fd57]{white-space:nowrap;padding-left:8px;padding-right:8px;-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1}.yd-tab-nav-scoll .yd-tab-nav .yd-tab-nav-item[data-v-6b20fd57]{padding:0 20px;display:inline-block}.yd-tab-nav[data-v-6b20fd57]{position:relative;z-index:0}.yd-tab-nav[data-v-6b20fd57]:after{height:1px;position:absolute;z-index:3;bottom:0;left:0;content:\\\"\\\";width:100%;background-image:-webkit-gradient(linear,left bottom,left top,color-stop(50%,#b2b2b2),color-stop(50%,transparent));background-image:-webkit-linear-gradient(bottom,#b2b2b2 50%,transparent 0);background-image:linear-gradient(0deg,#b2b2b2 50%,transparent 0)}.yd-tab-nav-item[data-v-6b20fd57]{-webkit-transition:background-color .25s cubic-bezier(.8,.1,.1,1) 0s;transition:background-color .25s cubic-bezier(.8,.1,.1,1) 0s;position:relative;text-align:center;color:#585858;font-size:14px;line-height:30px;background-color:#fff}.yd-tab-nav-item[data-v-6b20fd57]:active{background-color:#f7f7f7}.yd-tab-nav-item>a[data-v-6b20fd57]{display:inherit;color:inherit}.yd-tab-nav-item[data-v-6b20fd57]:not(:last-child):after{position:absolute;top:35%;right:0;content:\\\"\\\";width:1px;height:30%;-webkit-transform:scaleX(.5);transform:scaleX(.5);border-right:1px solid #d9d9d9}.yd-tab-nav .yd-tab-active[data-v-6b20fd57]{color:currentColor;background-color:#fff}.yd-tab-nav .yd-tab-active[data-v-6b20fd57]:active{background-color:#fff}.yd-tab-nav .yd-tab-active[data-v-6b20fd57]:before{content:\\\"\\\";width:70%;height:2px;position:absolute;left:50%;bottom:0;margin-left:-35%;z-index:4;background-color:currentColor}.yd-tab-panel[data-v-6b20fd57]{position:relative;overflow:hidden;background-color:#fff}.yd-tab-panel-item[data-v-6b20fd57]{width:100%;position:absolute;top:0;-webkit-transform:translateX(-100%);transform:translateX(-100%)}.yd-tab-panel-item.yd-tab-active[data-v-6b20fd57]{position:relative;-webkit-transition-timing-function:ease-in-out;transition-timing-function:ease-in-out;-webkit-transition:-webkit-transform .3s;transition:-webkit-transform .3s;transition:transform .3s;transition:transform .3s,-webkit-transform .3s;-webkit-transform:translateX(0);transform:translateX(0)}.yd-tab-panel-item.yd-tab-active~.yd-tab-panel-item[data-v-6b20fd57]{-webkit-transform:translateX(100%);transform:translateX(100%)}.scroll[data-v-6b20fd57]{position:relative}.scroll__graphic[data-v-6b20fd57]{position:-webkit-sticky;position:sticky;z-index:100;top:0;-webkit-transform:translateZ(0);transform:translateZ(0)}.yd-sticky-panel[data-v-6b20fd57]{position:relative}.sticky-nav[data-v-6b20fd57]{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;box-shadow:inset 2px 14px #888;-webkit-box-shadow:0 2px 14px #888;-moz-box-shadow:0 2px 14px #888}.sticky-nav .yd-tab-active[data-v-6b20fd57]{color:currentColor;background-color:#fff}.sticky-nav .yd-tab-active [data-v-6b20fd57]:before{content:\\\"\\\";width:70%;height:2px;position:absolute;left:50%;bottom:0;margin-left:-35%;z-index:4;background-color:currentColor}.sticky-nav .yd-tab-nav-item[data-v-6b20fd57]{font-size:16px;line-height:42px;-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1}.sticky-nav .yd-tab-nav-item[data-v-6b20fd57]:not(:last-child):after{display:none}.sticky-nav ul[data-v-6b20fd57]:after{content:\\\"\\\";width:100%;height:2px;position:absolute;left:0;bottom:0;z-index:4;background-color:currentColor}.yd-lyout-footer[data-v-6b20fd57]{position:fixed;bottom:0}\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_css-loader@0.26.4@css-loader?minimize!./~/_vue-loader@10.3.0@vue-loader/lib/style-rewriter.js?id=data-v-6b20fd57&scoped=true!./~/_less-loader@2.2.3@less-loader!./~/_vue-loader@10.3.0@vue-loader/lib/selector.js?type=styles&index=0!./~/_string-replace-webpack-plugin@0.1.3@string-replace-webpack-plugin/loader.js?id=tm1l2r4ciqb!./src/components/stickynav/src/stickynav.vue\n// module id = 140\n// module chunks = 5","/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.\n *\n *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document\n *\n */\n\n(function(window, document) {\n'use strict';\n\n\n// Exits early if all IntersectionObserver and IntersectionObserverEntry\n// features are natively supported.\nif ('IntersectionObserver' in window &&\n    'IntersectionObserverEntry' in window &&\n    'intersectionRatio' in window.IntersectionObserverEntry.prototype) {\n\n  // Minimal polyfill for Edge 15's lack of `isIntersecting`\n  // See: https://github.com/w3c/IntersectionObserver/issues/211\n  if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {\n    Object.defineProperty(window.IntersectionObserverEntry.prototype,\n      'isIntersecting', {\n      get: function () {\n        return this.intersectionRatio > 0;\n      }\n    });\n  }\n  return;\n}\n\n\n/**\n * An IntersectionObserver registry. This registry exists to hold a strong\n * reference to IntersectionObserver instances currently observering a target\n * element. Without this registry, instances without another reference may be\n * garbage collected.\n */\nvar registry = [];\n\n\n/**\n * Creates the global IntersectionObserverEntry constructor.\n * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry\n * @param {Object} entry A dictionary of instance properties.\n * @constructor\n */\nfunction IntersectionObserverEntry(entry) {\n  this.time = entry.time;\n  this.target = entry.target;\n  this.rootBounds = entry.rootBounds;\n  this.boundingClientRect = entry.boundingClientRect;\n  this.intersectionRect = entry.intersectionRect || getEmptyRect();\n  this.isIntersecting = !!entry.intersectionRect;\n\n  // Calculates the intersection ratio.\n  var targetRect = this.boundingClientRect;\n  var targetArea = targetRect.width * targetRect.height;\n  var intersectionRect = this.intersectionRect;\n  var intersectionArea = intersectionRect.width * intersectionRect.height;\n\n  // Sets intersection ratio.\n  if (targetArea) {\n    this.intersectionRatio = intersectionArea / targetArea;\n  } else {\n    // If area is zero and is intersecting, sets to 1, otherwise to 0\n    this.intersectionRatio = this.isIntersecting ? 1 : 0;\n  }\n}\n\n\n/**\n * Creates the global IntersectionObserver constructor.\n * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface\n * @param {Function} callback The function to be invoked after intersection\n *     changes have queued. The function is not invoked if the queue has\n *     been emptied by calling the `takeRecords` method.\n * @param {Object=} opt_options Optional configuration options.\n * @constructor\n */\nfunction IntersectionObserver(callback, opt_options) {\n\n  var options = opt_options || {};\n\n  if (typeof callback != 'function') {\n    throw new Error('callback must be a function');\n  }\n\n  if (options.root && options.root.nodeType != 1) {\n    throw new Error('root must be an Element');\n  }\n\n  // Binds and throttles `this._checkForIntersections`.\n  this._checkForIntersections = throttle(\n      this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);\n\n  // Private properties.\n  this._callback = callback;\n  this._observationTargets = [];\n  this._queuedEntries = [];\n  this._rootMarginValues = this._parseRootMargin(options.rootMargin);\n\n  // Public properties.\n  this.thresholds = this._initThresholds(options.threshold);\n  this.root = options.root || null;\n  this.rootMargin = this._rootMarginValues.map(function(margin) {\n    return margin.value + margin.unit;\n  }).join(' ');\n}\n\n\n/**\n * The minimum interval within which the document will be checked for\n * intersection changes.\n */\nIntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;\n\n\n/**\n * The frequency in which the polyfill polls for intersection changes.\n * this can be updated on a per instance basis and must be set prior to\n * calling `observe` on the first target.\n */\nIntersectionObserver.prototype.POLL_INTERVAL = null;\n\n/**\n * Use a mutation observer on the root element\n * to detect intersection changes.\n */\nIntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;\n\n\n/**\n * Starts observing a target element for intersection changes based on\n * the thresholds values.\n * @param {Element} target The DOM element to observe.\n */\nIntersectionObserver.prototype.observe = function(target) {\n  var isTargetAlreadyObserved = this._observationTargets.some(function(item) {\n    return item.element == target;\n  });\n\n  if (isTargetAlreadyObserved) {\n    return;\n  }\n\n  if (!(target && target.nodeType == 1)) {\n    throw new Error('target must be an Element');\n  }\n\n  this._registerInstance();\n  this._observationTargets.push({element: target, entry: null});\n  this._monitorIntersections();\n  this._checkForIntersections();\n};\n\n\n/**\n * Stops observing a target element for intersection changes.\n * @param {Element} target The DOM element to observe.\n */\nIntersectionObserver.prototype.unobserve = function(target) {\n  this._observationTargets =\n      this._observationTargets.filter(function(item) {\n\n    return item.element != target;\n  });\n  if (!this._observationTargets.length) {\n    this._unmonitorIntersections();\n    this._unregisterInstance();\n  }\n};\n\n\n/**\n * Stops observing all target elements for intersection changes.\n */\nIntersectionObserver.prototype.disconnect = function() {\n  this._observationTargets = [];\n  this._unmonitorIntersections();\n  this._unregisterInstance();\n};\n\n\n/**\n * Returns any queue entries that have not yet been reported to the\n * callback and clears the queue. This can be used in conjunction with the\n * callback to obtain the absolute most up-to-date intersection information.\n * @return {Array} The currently queued entries.\n */\nIntersectionObserver.prototype.takeRecords = function() {\n  var records = this._queuedEntries.slice();\n  this._queuedEntries = [];\n  return records;\n};\n\n\n/**\n * Accepts the threshold value from the user configuration object and\n * returns a sorted array of unique threshold values. If a value is not\n * between 0 and 1 and error is thrown.\n * @private\n * @param {Array|number=} opt_threshold An optional threshold value or\n *     a list of threshold values, defaulting to [0].\n * @return {Array} A sorted list of unique and valid threshold values.\n */\nIntersectionObserver.prototype._initThresholds = function(opt_threshold) {\n  var threshold = opt_threshold || [0];\n  if (!Array.isArray(threshold)) threshold = [threshold];\n\n  return threshold.sort().filter(function(t, i, a) {\n    if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {\n      throw new Error('threshold must be a number between 0 and 1 inclusively');\n    }\n    return t !== a[i - 1];\n  });\n};\n\n\n/**\n * Accepts the rootMargin value from the user configuration object\n * and returns an array of the four margin values as an object containing\n * the value and unit properties. If any of the values are not properly\n * formatted or use a unit other than px or %, and error is thrown.\n * @private\n * @param {string=} opt_rootMargin An optional rootMargin value,\n *     defaulting to '0px'.\n * @return {Array<Object>} An array of margin objects with the keys\n *     value and unit.\n */\nIntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {\n  var marginString = opt_rootMargin || '0px';\n  var margins = marginString.split(/\\s+/).map(function(margin) {\n    var parts = /^(-?\\d*\\.?\\d+)(px|%)$/.exec(margin);\n    if (!parts) {\n      throw new Error('rootMargin must be specified in pixels or percent');\n    }\n    return {value: parseFloat(parts[1]), unit: parts[2]};\n  });\n\n  // Handles shorthand.\n  margins[1] = margins[1] || margins[0];\n  margins[2] = margins[2] || margins[0];\n  margins[3] = margins[3] || margins[1];\n\n  return margins;\n};\n\n\n/**\n * Starts polling for intersection changes if the polling is not already\n * happening, and if the page's visibilty state is visible.\n * @private\n */\nIntersectionObserver.prototype._monitorIntersections = function() {\n  if (!this._monitoringIntersections) {\n    this._monitoringIntersections = true;\n\n    // If a poll interval is set, use polling instead of listening to\n    // resize and scroll events or DOM mutations.\n    if (this.POLL_INTERVAL) {\n      this._monitoringInterval = setInterval(\n          this._checkForIntersections, this.POLL_INTERVAL);\n    }\n    else {\n      addEvent(window, 'resize', this._checkForIntersections, true);\n      addEvent(document, 'scroll', this._checkForIntersections, true);\n\n      if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in window) {\n        this._domObserver = new MutationObserver(this._checkForIntersections);\n        this._domObserver.observe(document, {\n          attributes: true,\n          childList: true,\n          characterData: true,\n          subtree: true\n        });\n      }\n    }\n  }\n};\n\n\n/**\n * Stops polling for intersection changes.\n * @private\n */\nIntersectionObserver.prototype._unmonitorIntersections = function() {\n  if (this._monitoringIntersections) {\n    this._monitoringIntersections = false;\n\n    clearInterval(this._monitoringInterval);\n    this._monitoringInterval = null;\n\n    removeEvent(window, 'resize', this._checkForIntersections, true);\n    removeEvent(document, 'scroll', this._checkForIntersections, true);\n\n    if (this._domObserver) {\n      this._domObserver.disconnect();\n      this._domObserver = null;\n    }\n  }\n};\n\n\n/**\n * Scans each observation target for intersection changes and adds them\n * to the internal entries queue. If new entries are found, it\n * schedules the callback to be invoked.\n * @private\n */\nIntersectionObserver.prototype._checkForIntersections = function() {\n  var rootIsInDom = this._rootIsInDom();\n  var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();\n\n  this._observationTargets.forEach(function(item) {\n    var target = item.element;\n    var targetRect = getBoundingClientRect(target);\n    var rootContainsTarget = this._rootContainsTarget(target);\n    var oldEntry = item.entry;\n    var intersectionRect = rootIsInDom && rootContainsTarget &&\n        this._computeTargetAndRootIntersection(target, rootRect);\n\n    var newEntry = item.entry = new IntersectionObserverEntry({\n      time: now(),\n      target: target,\n      boundingClientRect: targetRect,\n      rootBounds: rootRect,\n      intersectionRect: intersectionRect\n    });\n\n    if (!oldEntry) {\n      this._queuedEntries.push(newEntry);\n    } else if (rootIsInDom && rootContainsTarget) {\n      // If the new entry intersection ratio has crossed any of the\n      // thresholds, add a new entry.\n      if (this._hasCrossedThreshold(oldEntry, newEntry)) {\n        this._queuedEntries.push(newEntry);\n      }\n    } else {\n      // If the root is not in the DOM or target is not contained within\n      // root but the previous entry for this target had an intersection,\n      // add a new record indicating removal.\n      if (oldEntry && oldEntry.isIntersecting) {\n        this._queuedEntries.push(newEntry);\n      }\n    }\n  }, this);\n\n  if (this._queuedEntries.length) {\n    this._callback(this.takeRecords(), this);\n  }\n};\n\n\n/**\n * Accepts a target and root rect computes the intersection between then\n * following the algorithm in the spec.\n * TODO(philipwalton): at this time clip-path is not considered.\n * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo\n * @param {Element} target The target DOM element\n * @param {Object} rootRect The bounding rect of the root after being\n *     expanded by the rootMargin value.\n * @return {?Object} The final intersection rect object or undefined if no\n *     intersection is found.\n * @private\n */\nIntersectionObserver.prototype._computeTargetAndRootIntersection =\n    function(target, rootRect) {\n\n  // If the element isn't displayed, an intersection can't happen.\n  if (window.getComputedStyle(target).display == 'none') return;\n\n  var targetRect = getBoundingClientRect(target);\n  var intersectionRect = targetRect;\n  var parent = getParentNode(target);\n  var atRoot = false;\n\n  while (!atRoot) {\n    var parentRect = null;\n    var parentComputedStyle = parent.nodeType == 1 ?\n        window.getComputedStyle(parent) : {};\n\n    // If the parent isn't displayed, an intersection can't happen.\n    if (parentComputedStyle.display == 'none') return;\n\n    if (parent == this.root || parent == document) {\n      atRoot = true;\n      parentRect = rootRect;\n    } else {\n      // If the element has a non-visible overflow, and it's not the <body>\n      // or <html> element, update the intersection rect.\n      // Note: <body> and <html> cannot be clipped to a rect that's not also\n      // the document rect, so no need to compute a new intersection.\n      if (parent != document.body &&\n          parent != document.documentElement &&\n          parentComputedStyle.overflow != 'visible') {\n        parentRect = getBoundingClientRect(parent);\n      }\n    }\n\n    // If either of the above conditionals set a new parentRect,\n    // calculate new intersection data.\n    if (parentRect) {\n      intersectionRect = computeRectIntersection(parentRect, intersectionRect);\n\n      if (!intersectionRect) break;\n    }\n    parent = getParentNode(parent);\n  }\n  return intersectionRect;\n};\n\n\n/**\n * Returns the root rect after being expanded by the rootMargin value.\n * @return {Object} The expanded root rect.\n * @private\n */\nIntersectionObserver.prototype._getRootRect = function() {\n  var rootRect;\n  if (this.root) {\n    rootRect = getBoundingClientRect(this.root);\n  } else {\n    // Use <html>/<body> instead of window since scroll bars affect size.\n    var html = document.documentElement;\n    var body = document.body;\n    rootRect = {\n      top: 0,\n      left: 0,\n      right: html.clientWidth || body.clientWidth,\n      width: html.clientWidth || body.clientWidth,\n      bottom: html.clientHeight || body.clientHeight,\n      height: html.clientHeight || body.clientHeight\n    };\n  }\n  return this._expandRectByRootMargin(rootRect);\n};\n\n\n/**\n * Accepts a rect and expands it by the rootMargin value.\n * @param {Object} rect The rect object to expand.\n * @return {Object} The expanded rect.\n * @private\n */\nIntersectionObserver.prototype._expandRectByRootMargin = function(rect) {\n  var margins = this._rootMarginValues.map(function(margin, i) {\n    return margin.unit == 'px' ? margin.value :\n        margin.value * (i % 2 ? rect.width : rect.height) / 100;\n  });\n  var newRect = {\n    top: rect.top - margins[0],\n    right: rect.right + margins[1],\n    bottom: rect.bottom + margins[2],\n    left: rect.left - margins[3]\n  };\n  newRect.width = newRect.right - newRect.left;\n  newRect.height = newRect.bottom - newRect.top;\n\n  return newRect;\n};\n\n\n/**\n * Accepts an old and new entry and returns true if at least one of the\n * threshold values has been crossed.\n * @param {?IntersectionObserverEntry} oldEntry The previous entry for a\n *    particular target element or null if no previous entry exists.\n * @param {IntersectionObserverEntry} newEntry The current entry for a\n *    particular target element.\n * @return {boolean} Returns true if a any threshold has been crossed.\n * @private\n */\nIntersectionObserver.prototype._hasCrossedThreshold =\n    function(oldEntry, newEntry) {\n\n  // To make comparing easier, an entry that has a ratio of 0\n  // but does not actually intersect is given a value of -1\n  var oldRatio = oldEntry && oldEntry.isIntersecting ?\n      oldEntry.intersectionRatio || 0 : -1;\n  var newRatio = newEntry.isIntersecting ?\n      newEntry.intersectionRatio || 0 : -1;\n\n  // Ignore unchanged ratios\n  if (oldRatio === newRatio) return;\n\n  for (var i = 0; i < this.thresholds.length; i++) {\n    var threshold = this.thresholds[i];\n\n    // Return true if an entry matches a threshold or if the new ratio\n    // and the old ratio are on the opposite sides of a threshold.\n    if (threshold == oldRatio || threshold == newRatio ||\n        threshold < oldRatio !== threshold < newRatio) {\n      return true;\n    }\n  }\n};\n\n\n/**\n * Returns whether or not the root element is an element and is in the DOM.\n * @return {boolean} True if the root element is an element and is in the DOM.\n * @private\n */\nIntersectionObserver.prototype._rootIsInDom = function() {\n  return !this.root || containsDeep(document, this.root);\n};\n\n\n/**\n * Returns whether or not the target element is a child of root.\n * @param {Element} target The target element to check.\n * @return {boolean} True if the target element is a child of root.\n * @private\n */\nIntersectionObserver.prototype._rootContainsTarget = function(target) {\n  return containsDeep(this.root || document, target);\n};\n\n\n/**\n * Adds the instance to the global IntersectionObserver registry if it isn't\n * already present.\n * @private\n */\nIntersectionObserver.prototype._registerInstance = function() {\n  if (registry.indexOf(this) < 0) {\n    registry.push(this);\n  }\n};\n\n\n/**\n * Removes the instance from the global IntersectionObserver registry.\n * @private\n */\nIntersectionObserver.prototype._unregisterInstance = function() {\n  var index = registry.indexOf(this);\n  if (index != -1) registry.splice(index, 1);\n};\n\n\n/**\n * Returns the result of the performance.now() method or null in browsers\n * that don't support the API.\n * @return {number} The elapsed time since the page was requested.\n */\nfunction now() {\n  return window.performance && performance.now && performance.now();\n}\n\n\n/**\n * Throttles a function and delays its executiong, so it's only called at most\n * once within a given time period.\n * @param {Function} fn The function to throttle.\n * @param {number} timeout The amount of time that must pass before the\n *     function can be called again.\n * @return {Function} The throttled function.\n */\nfunction throttle(fn, timeout) {\n  var timer = null;\n  return function () {\n    if (!timer) {\n      timer = setTimeout(function() {\n        fn();\n        timer = null;\n      }, timeout);\n    }\n  };\n}\n\n\n/**\n * Adds an event handler to a DOM node ensuring cross-browser compatibility.\n * @param {Node} node The DOM node to add the event handler to.\n * @param {string} event The event name.\n * @param {Function} fn The event handler to add.\n * @param {boolean} opt_useCapture Optionally adds the even to the capture\n *     phase. Note: this only works in modern browsers.\n */\nfunction addEvent(node, event, fn, opt_useCapture) {\n  if (typeof node.addEventListener == 'function') {\n    node.addEventListener(event, fn, opt_useCapture || false);\n  }\n  else if (typeof node.attachEvent == 'function') {\n    node.attachEvent('on' + event, fn);\n  }\n}\n\n\n/**\n * Removes a previously added event handler from a DOM node.\n * @param {Node} node The DOM node to remove the event handler from.\n * @param {string} event The event name.\n * @param {Function} fn The event handler to remove.\n * @param {boolean} opt_useCapture If the event handler was added with this\n *     flag set to true, it should be set to true here in order to remove it.\n */\nfunction removeEvent(node, event, fn, opt_useCapture) {\n  if (typeof node.removeEventListener == 'function') {\n    node.removeEventListener(event, fn, opt_useCapture || false);\n  }\n  else if (typeof node.detatchEvent == 'function') {\n    node.detatchEvent('on' + event, fn);\n  }\n}\n\n\n/**\n * Returns the intersection between two rect objects.\n * @param {Object} rect1 The first rect.\n * @param {Object} rect2 The second rect.\n * @return {?Object} The intersection rect or undefined if no intersection\n *     is found.\n */\nfunction computeRectIntersection(rect1, rect2) {\n  var top = Math.max(rect1.top, rect2.top);\n  var bottom = Math.min(rect1.bottom, rect2.bottom);\n  var left = Math.max(rect1.left, rect2.left);\n  var right = Math.min(rect1.right, rect2.right);\n  var width = right - left;\n  var height = bottom - top;\n\n  return (width >= 0 && height >= 0) && {\n    top: top,\n    bottom: bottom,\n    left: left,\n    right: right,\n    width: width,\n    height: height\n  };\n}\n\n\n/**\n * Shims the native getBoundingClientRect for compatibility with older IE.\n * @param {Element} el The element whose bounding rect to get.\n * @return {Object} The (possibly shimmed) rect of the element.\n */\nfunction getBoundingClientRect(el) {\n  var rect;\n\n  try {\n    rect = el.getBoundingClientRect();\n  } catch (err) {\n    // Ignore Windows 7 IE11 \"Unspecified error\"\n    // https://github.com/w3c/IntersectionObserver/pull/205\n  }\n\n  if (!rect) return getEmptyRect();\n\n  // Older IE\n  if (!(rect.width && rect.height)) {\n    rect = {\n      top: rect.top,\n      right: rect.right,\n      bottom: rect.bottom,\n      left: rect.left,\n      width: rect.right - rect.left,\n      height: rect.bottom - rect.top\n    };\n  }\n  return rect;\n}\n\n\n/**\n * Returns an empty rect object. An empty rect is returned when an element\n * is not in the DOM.\n * @return {Object} The empty rect.\n */\nfunction getEmptyRect() {\n  return {\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0,\n    width: 0,\n    height: 0\n  };\n}\n\n/**\n * Checks to see if a parent element contains a child elemnt (including inside\n * shadow DOM).\n * @param {Node} parent The parent element.\n * @param {Node} child The child element.\n * @return {boolean} True if the parent node contains the child node.\n */\nfunction containsDeep(parent, child) {\n  var node = child;\n  while (node) {\n    if (node == parent) return true;\n\n    node = getParentNode(node);\n  }\n  return false;\n}\n\n\n/**\n * Gets the parent node of an element or its host element if the parent node\n * is a shadow root.\n * @param {Node} node The node whose parent to get.\n * @return {Node|null} The parent node or null if no parent exists.\n */\nfunction getParentNode(node) {\n  var parent = node.parentNode;\n\n  if (parent && parent.nodeType == 11 && parent.host) {\n    // If the parent is a shadow root, return the host element.\n    return parent.host;\n  }\n  return parent;\n}\n\n\n// Exposes the constructors globally.\nwindow.IntersectionObserver = IntersectionObserver;\nwindow.IntersectionObserverEntry = IntersectionObserverEntry;\n\n}(window, document));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_intersection-observer@0.5.0@intersection-observer/intersection-observer.js\n// module id = 158\n// module chunks = 5","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.Jump = factory());\n}(this, (function () { 'use strict';\n\n// Robert Penner's easeInOutQuad\n\n// find the rest of his easing functions here: http://robertpenner.com/easing/\n// find them exported for ES6 consumption here: https://github.com/jaxgeller/ez.js\n\nvar easeInOutQuad = function easeInOutQuad(t, b, c, d) {\n  t /= d / 2;\n  if (t < 1) return c / 2 * t * t + b;\n  t--;\n  return -c / 2 * (t * (t - 2) - 1) + b;\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar jumper = function jumper() {\n  // private variable cache\n  // no variables are created during a jump, preventing memory leaks\n\n  var element = void 0; // element to scroll to                   (node)\n\n  var start = void 0; // where scroll starts                    (px)\n  var stop = void 0; // where scroll stops                     (px)\n\n  var offset = void 0; // adjustment from the stop position      (px)\n  var easing = void 0; // easing function                        (function)\n  var a11y = void 0; // accessibility support flag             (boolean)\n\n  var distance = void 0; // distance of scroll                     (px)\n  var duration = void 0; // scroll duration                        (ms)\n\n  var timeStart = void 0; // time scroll started                    (ms)\n  var timeElapsed = void 0; // time spent scrolling thus far          (ms)\n\n  var next = void 0; // next scroll position                   (px)\n\n  var callback = void 0; // to call when done scrolling            (function)\n\n  // scroll position helper\n\n  function location() {\n    return window.scrollY || window.pageYOffset;\n  }\n\n  // element offset helper\n\n  function top(element) {\n    return element.getBoundingClientRect().top + start;\n  }\n\n  // rAF loop helper\n\n  function loop(timeCurrent) {\n    // store time scroll started, if not started already\n    if (!timeStart) {\n      timeStart = timeCurrent;\n    }\n\n    // determine time spent scrolling so far\n    timeElapsed = timeCurrent - timeStart;\n\n    // calculate next scroll position\n    next = easing(timeElapsed, start, distance, duration);\n\n    // scroll to it\n    window.scrollTo(0, next);\n\n    // check progress\n    timeElapsed < duration ? window.requestAnimationFrame(loop) // continue scroll loop\n    : done(); // scrolling is done\n  }\n\n  // scroll finished helper\n\n  function done() {\n    // account for rAF time rounding inaccuracies\n    window.scrollTo(0, start + distance);\n\n    // if scrolling to an element, and accessibility is enabled\n    if (element && a11y) {\n      // add tabindex indicating programmatic focus\n      element.setAttribute('tabindex', '-1');\n\n      // focus the element\n      element.focus();\n    }\n\n    // if it exists, fire the callback\n    if (typeof callback === 'function') {\n      callback();\n    }\n\n    // reset time for next jump\n    timeStart = false;\n  }\n\n  // API\n\n  function jump(target) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    // resolve options, or use defaults\n    duration = options.duration || 1000;\n    offset = options.offset || 0;\n    callback = options.callback; // \"undefined\" is a suitable default, and won't be called\n    easing = options.easing || easeInOutQuad;\n    a11y = options.a11y || false;\n\n    // cache starting position\n    start = location();\n\n    // resolve target\n    switch (typeof target === 'undefined' ? 'undefined' : _typeof(target)) {\n      // scroll from current position\n      case 'number':\n        element = undefined; // no element to scroll to\n        a11y = false; // make sure accessibility is off\n        stop = start + target;\n        break;\n\n      // scroll to element (node)\n      // bounding rect is relative to the viewport\n      case 'object':\n        element = target;\n        stop = top(element);\n        break;\n\n      // scroll to element (selector)\n      // bounding rect is relative to the viewport\n      case 'string':\n        element = document.querySelector(target);\n        stop = top(element);\n        break;\n    }\n\n    // resolve scroll distance, accounting for offset\n    distance = stop - start + offset;\n\n    // resolve duration\n    switch (_typeof(options.duration)) {\n      // number in ms\n      case 'number':\n        duration = options.duration;\n        break;\n\n      // function passed the distance of the scroll\n      case 'function':\n        duration = options.duration(distance);\n        break;\n    }\n\n    // start the loop\n    window.requestAnimationFrame(loop);\n  }\n\n  // expose only the jump method\n  return jump;\n};\n\n// export singleton\n\nvar singleton = jumper();\n\nreturn singleton;\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_jump.js@1.0.2@jump.js/dist/jump.js\n// module id = 159\n// module chunks = 5","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.scrollama = factory());\n}(this, (function () { 'use strict';\n\n// DOM helper functions\n\n// private\nfunction selectionToArray(selection) {\n  var len = selection.length;\n  var result = [];\n  for (var i = 0; i < len; i += 1) {\n    result.push(selection[i]);\n  }\n  return result;\n}\n\n// public\nfunction select(selector) {\n  if (selector instanceof Element) { return selector; }\n  else if (typeof selector === 'string')\n    { return document.querySelector(selector); }\n  return null;\n}\n\nfunction selectAll(selector, parent) {\n  if ( parent === void 0 ) parent = document;\n\n  if (typeof selector === 'string') {\n    return selectionToArray(parent.querySelectorAll(selector));\n  } else if (selector instanceof Element) {\n    return selectionToArray([selector]);\n  } else if (selector instanceof NodeList) {\n    return selectionToArray(selector);\n  } else if (selector instanceof Array) {\n    return selector;\n  }\n  return [];\n}\n\nfunction getStepId(ref) {\n  var id = ref.id;\n  var i = ref.i;\n\n  return (\"scrollama__debug-step--\" + id + \"-\" + i);\n}\n\nfunction getOffsetId(ref) {\n  var id = ref.id;\n\n  return (\"scrollama__debug-offset--\" + id);\n}\n\n// SETUP\n\nfunction setupOffset(ref) {\n  var id = ref.id;\n  var offsetVal = ref.offsetVal;\n  var stepClass = ref.stepClass;\n\n  var el = document.createElement('div');\n  el.setAttribute('id', getOffsetId({ id: id }));\n  el.setAttribute('class', 'scrollama__debug-offset');\n\n  el.style.position = 'fixed';\n  el.style.left = '0';\n  el.style.width = '100%';\n  el.style.height = '0px';\n  el.style.borderTop = '2px dashed black';\n  el.style.zIndex = '9999';\n\n  var text = document.createElement('p');\n  text.innerText = \"\\\".\" + stepClass + \"\\\" trigger: \" + offsetVal;\n  text.style.fontSize = '12px';\n  text.style.fontFamily = 'monospace';\n  text.style.color = 'black';\n  text.style.margin = '0';\n  text.style.padding = '6px';\n  el.appendChild(text);\n  document.body.appendChild(el);\n}\n\nfunction setup(ref) {\n  var id = ref.id;\n  var offsetVal = ref.offsetVal;\n  var stepEl = ref.stepEl;\n\n  var stepClass = stepEl[0].getAttribute('class');\n  setupOffset({ id: id, offsetVal: offsetVal, stepClass: stepClass });\n}\n\n// UPDATE\nfunction updateOffset(ref) {\n  var id = ref.id;\n  var offsetMargin = ref.offsetMargin;\n  var offsetVal = ref.offsetVal;\n\n  var idVal = getOffsetId({ id: id });\n  var el = document.querySelector((\"#\" + idVal));\n  el.style.top = offsetMargin + \"px\";\n}\n\nfunction update(ref) {\n  var id = ref.id;\n  var stepOffsetHeight = ref.stepOffsetHeight;\n  var offsetMargin = ref.offsetMargin;\n  var offsetVal = ref.offsetVal;\n\n  updateOffset({ id: id, offsetMargin: offsetMargin });\n}\n\nfunction notifyStep(ref) {\n  var id = ref.id;\n  var index = ref.index;\n  var state = ref.state;\n\n  var idVal = getStepId({ id: id, i: index });\n  var elA = document.querySelector((\"#\" + idVal + \"_above\"));\n  var elB = document.querySelector((\"#\" + idVal + \"_below\"));\n  var display = state === 'enter' ? 'block' : 'none';\n\n  if (elA) { elA.style.display = display; }\n  if (elB) { elB.style.display = display; }\n}\n\nfunction scrollama() {\n  var ZERO_MOE = 1; // zero with some rounding margin of error\n  var callback = {};\n  var io = {};\n\n  var containerEl = null;\n  var graphicEl = null;\n  var stepEl = null;\n\n  var id = null;\n  var offsetVal = 0;\n  var offsetMargin = 0;\n  var vh = 0;\n  var ph = 0;\n  var stepOffsetHeight = null;\n  var stepOffsetTop = null;\n  var bboxGraphic = null;\n\n  var isReady = false;\n  var isEnabled = false;\n  var debugMode = false;\n  var progressMode = false;\n  var progressThreshold = 0;\n  var preserveOrder = false;\n  var triggerOnce = false;\n\n  var stepStates = null;\n  var containerState = null;\n  var previousYOffset = -1;\n  var direction = null;\n\n  var exclude = [];\n\n  // HELPERS\n  function generateId() {\n    var a = 'abcdefghijklmnopqrstuv';\n    var l = a.length;\n    var t = new Date().getTime();\n    var r = [0, 0, 0].map(function (d) { return a[Math.floor(Math.random() * l)]; }).join('');\n    return (\"\" + r + t);\n  }\n\n  //www.gomakethings.com/how-to-get-an-elements-distance-from-the-top-of-the-page-with-vanilla-javascript/\n  function getOffsetTop(el) {\n    // Set our distance placeholder\n    var distance = 0;\n\n    // Loop up the DOM\n    if (el.offsetParent) {\n      do {\n        distance += el.offsetTop;\n        el = el.offsetParent;\n      } while (el);\n    }\n\n    // Return our distance\n    return distance < 0 ? 0 : distance;\n  }\n\n  function getPageHeight() {\n    var body = document.body;\n    var html = document.documentElement;\n\n    return Math.max(\n      body.scrollHeight,\n      body.offsetHeight,\n      html.clientHeight,\n      html.scrollHeight,\n      html.offsetHeight\n    );\n  }\n\n  function getIndex(element) {\n    return +element.getAttribute('data-scrollama-index');\n  }\n\n  function updateDirection() {\n    if (window.pageYOffset > previousYOffset) { direction = 'down'; }\n    else if (window.pageYOffset < previousYOffset) { direction = 'up'; }\n    previousYOffset = window.pageYOffset;\n  }\n\n  function handleResize() {\n    vh = window.innerHeight;\n    ph = getPageHeight();\n\n    bboxGraphic = graphicEl ? graphicEl.getBoundingClientRect() : null;\n\n    offsetMargin = offsetVal * vh;\n\n    stepOffsetHeight = stepEl ? stepEl.map(function (el) { return el.offsetHeight; }) : [];\n\n    stepOffsetTop = stepEl ? stepEl.map(getOffsetTop) : [];\n\n    if (isEnabled && isReady) { updateIO(); }\n\n    if (debugMode)\n      { update({ id: id, stepOffsetHeight: stepOffsetHeight, offsetMargin: offsetMargin, offsetVal: offsetVal }); }\n  }\n\n  function handleEnable(enable) {\n    if (enable && !isEnabled) {\n      if (isReady) { updateIO(); }\n      isEnabled = true;\n    } else if (!enable) {\n      if (io.top) { io.top.disconnect(); }\n      if (io.bottom) { io.bottom.disconnect(); }\n      if (io.stepAbove) { io.stepAbove.forEach(function (d) { return d.disconnect(); }); }\n      if (io.stepBelow) { io.stepBelow.forEach(function (d) { return d.disconnect(); }); }\n      if (io.stepProgress) { io.stepProgress.forEach(function (d) { return d.disconnect(); }); }\n      if (io.viewportAbove) { io.viewportAbove.forEach(function (d) { return d.disconnect(); }); }\n      if (io.viewportBelow) { io.viewportBelow.forEach(function (d) { return d.disconnect(); }); }\n      isEnabled = false;\n    }\n  }\n\n  function createThreshold(height) {\n    var count = Math.ceil(height / progressThreshold);\n    var t = [];\n    var ratio = 1 / count;\n    for (var i = 0; i < count; i++) {\n      t.push(i * ratio);\n    }\n    return t;\n  }\n\n  // NOTIFY CALLBACKS\n  function notifyOthers(index, location) {\n    if (location === 'above') {\n      // check if steps above/below were skipped and should be notified first\n      for (var i = 0; i < index; i++) {\n        var ss = stepStates[i];\n        if (ss.state === 'enter') { notifyStepExit(stepEl[i], 'down'); }\n        if (ss.direction === 'up') {\n          notifyStepEnter(stepEl[i], 'down', false);\n          notifyStepExit(stepEl[i], 'down');\n        }\n      }\n    } else if (location === 'below') {\n      for (var i$1 = stepStates.length - 1; i$1 > index; i$1--) {\n        var ss$1 = stepStates[i$1];\n        if (ss$1.state === 'enter') {\n          notifyStepExit(stepEl[i$1], 'up');\n        }\n        if (ss$1.direction === 'down') {\n          notifyStepEnter(stepEl[i$1], 'up', false);\n          notifyStepExit(stepEl[i$1], 'up');\n        }\n      }\n    }\n  }\n\n  function notifyStepEnter(element, direction, check) {\n    if ( check === void 0 ) check = true;\n\n    var index = getIndex(element);\n    var resp = { element: element, index: index, direction: direction };\n\n    // store most recent trigger\n    stepStates[index].direction = direction;\n    stepStates[index].state = 'enter';\n\n    if (preserveOrder && check && direction === 'down')\n      { notifyOthers(index, 'above'); }\n\n    if (preserveOrder && check && direction === 'up')\n      { notifyOthers(index, 'below'); }\n\n    if (\n      callback.stepEnter &&\n      typeof callback.stepEnter === 'function' &&\n      !exclude[index]\n    ) {\n      callback.stepEnter(resp, stepStates);\n      if (debugMode) { notifyStep({ id: id, index: index, state: 'enter' }); }\n      if (triggerOnce) { exclude[index] = true; }\n    }\n\n    if (progressMode) {\n      if (direction === 'down') { notifyStepProgress(element, 0); }\n      else { notifyStepProgress(element, 1); }\n    }\n  }\n\n  function notifyStepExit(element, direction) {\n    var index = getIndex(element);\n    var resp = { element: element, index: index, direction: direction };\n\n    // store most recent trigger\n    stepStates[index].direction = direction;\n    stepStates[index].state = 'exit';\n\n    if (progressMode) {\n      if (direction === 'down') { notifyStepProgress(element, 1); }\n      else { notifyStepProgress(element, 0); }\n    }\n\n    if (callback.stepExit && typeof callback.stepExit === 'function') {\n      callback.stepExit(resp, stepStates);\n      if (debugMode) { notifyStep({ id: id, index: index, state: 'exit' }); }\n    }\n  }\n\n  function notifyStepProgress(element, progress) {\n    var index = getIndex(element);\n    var resp = { element: element, index: index, progress: progress };\n    if (callback.stepProgress && typeof callback.stepProgress === 'function')\n      { callback.stepProgress(resp); }\n  }\n\n  function notifyContainerEnter() {\n    var resp = { direction: direction };\n    containerState.direction = direction;\n    containerState.state = 'enter';\n    if (\n      callback.containerEnter &&\n      typeof callback.containerEnter === 'function'\n    )\n      { callback.containerEnter(resp); }\n  }\n\n  function notifyContainerExit() {\n    var resp = { direction: direction };\n    containerState.direction = direction;\n    containerState.state = 'exit';\n    if (callback.containerExit && typeof callback.containerExit === 'function')\n      { callback.containerExit(resp); }\n  }\n\n  // OBSERVER - INTERSECT HANDLING\n\n  // if TOP edge of step crosses threshold,\n  // bottom must be > 0 which means it is on \"screen\" (shifted by offset)\n  function intersectStepAbove(entries) {\n    updateDirection();\n    entries.forEach(function (entry) {\n      var isIntersecting = entry.isIntersecting;\n      var boundingClientRect = entry.boundingClientRect;\n      var target = entry.target;\n\n      // bottom is how far bottom edge of el is from top of viewport\n      var bottom = boundingClientRect.bottom;\n      var height = boundingClientRect.height;\n      var bottomAdjusted = bottom - offsetMargin;\n      var index = getIndex(target);\n      var ss = stepStates[index];\n\n      if (bottomAdjusted >= -ZERO_MOE) {\n        if (isIntersecting && direction === 'down' && ss.state !== 'enter')\n          { notifyStepEnter(target, direction); }\n        else if (!isIntersecting && direction === 'up' && ss.state === 'enter')\n          { notifyStepExit(target, direction); }\n        else if (\n          !isIntersecting &&\n          bottomAdjusted >= height &&\n          direction === 'down' &&\n          ss.state === 'enter'\n        ) {\n          notifyStepExit(target, direction);\n        }\n      }\n    });\n  }\n\n  function intersectStepBelow(entries) {\n    updateDirection();\n    entries.forEach(function (entry) {\n      var isIntersecting = entry.isIntersecting;\n      var boundingClientRect = entry.boundingClientRect;\n      var target = entry.target;\n\n      var bottom = boundingClientRect.bottom;\n      var height = boundingClientRect.height;\n      var bottomAdjusted = bottom - offsetMargin;\n      var index = getIndex(target);\n      var ss = stepStates[index];\n\n      if (\n        bottomAdjusted >= -ZERO_MOE &&\n        bottomAdjusted < height &&\n        isIntersecting &&\n        direction === 'up' &&\n        ss.state !== 'enter'\n      ) {\n        notifyStepEnter(target, direction);\n      } else if (\n        bottomAdjusted <= ZERO_MOE &&\n        !isIntersecting &&\n        direction === 'down' &&\n        ss.state === 'enter'\n      ) {\n        notifyStepExit(target, direction);\n      }\n    });\n  }\n\n  /*\n\tif there is a scroll event where a step never intersects (therefore\n\tskipping an enter/exit trigger), use this fallback to detect if it is\n\tin view\n\t*/\n  function intersectViewportAbove(entries) {\n    updateDirection();\n    entries.forEach(function (entry) {\n      var isIntersecting = entry.isIntersecting;\n      var target = entry.target;\n      var index = getIndex(target);\n      var ss = stepStates[index];\n      if (\n        isIntersecting &&\n        direction === 'down' &&\n        ss.state !== 'enter' &&\n        ss.direction !== 'down'\n      ) {\n        notifyStepEnter(target, 'down');\n        notifyStepExit(target, 'down');\n      }\n    });\n  }\n\n  function intersectViewportBelow(entries) {\n    updateDirection();\n    entries.forEach(function (entry) {\n      var isIntersecting = entry.isIntersecting;\n      var target = entry.target;\n      var index = getIndex(target);\n      var ss = stepStates[index];\n      if (\n        isIntersecting &&\n        direction === 'up' &&\n        ss.state !== 'enter' &&\n        ss.direction !== 'up'\n      ) {\n        notifyStepEnter(target, 'up');\n        notifyStepExit(target, 'up');\n      }\n    });\n  }\n\n  function intersectStepProgress(entries) {\n    updateDirection();\n    entries.forEach(\n      function (ref) {\n        var isIntersecting = ref.isIntersecting;\n        var intersectionRatio = ref.intersectionRatio;\n        var boundingClientRect = ref.boundingClientRect;\n        var target = ref.target;\n\n        var bottom = boundingClientRect.bottom;\n        var bottomAdjusted = bottom - offsetMargin;\n\n        if (isIntersecting && bottomAdjusted >= -ZERO_MOE) {\n          notifyStepProgress(target, +intersectionRatio.toFixed(3));\n        }\n      }\n    );\n  }\n\n  function intersectTop(entries) {\n    updateDirection();\n    var ref = entries[0];\n    var isIntersecting = ref.isIntersecting;\n    var boundingClientRect = ref.boundingClientRect;\n    var top = boundingClientRect.top;\n    var bottom = boundingClientRect.bottom;\n\n    if (bottom > -ZERO_MOE) {\n      if (isIntersecting) { notifyContainerEnter(direction); }\n      else if (containerState.state === 'enter') { notifyContainerExit(direction); }\n    }\n  }\n\n  function intersectBottom(entries) {\n    updateDirection();\n    var ref = entries[0];\n    var isIntersecting = ref.isIntersecting;\n    var boundingClientRect = ref.boundingClientRect;\n    var top = boundingClientRect.top;\n\n    if (top < ZERO_MOE) {\n      if (isIntersecting) { notifyContainerEnter(direction); }\n      else if (containerState.state === 'enter') { notifyContainerExit(direction); }\n    }\n  }\n\n  // OBSERVER - CREATION\n\n  function updateTopIO() {\n    if (io.top) { io.top.unobserve(containerEl); }\n\n    var options = {\n      root: null,\n      rootMargin: (vh + \"px 0px -\" + vh + \"px 0px\"),\n      threshold: 0\n    };\n\n    io.top = new IntersectionObserver(intersectTop, options);\n    io.top.observe(containerEl);\n  }\n\n  function updateBottomIO() {\n    if (io.bottom) { io.bottom.unobserve(containerEl); }\n    var options = {\n      root: null,\n      rootMargin: (\"-\" + (bboxGraphic.height) + \"px 0px \" + (bboxGraphic.height) + \"px 0px\"),\n      threshold: 0\n    };\n\n    io.bottom = new IntersectionObserver(intersectBottom, options);\n    io.bottom.observe(containerEl);\n  }\n\n  // top edge\n  function updateStepAboveIO() {\n    if (io.stepAbove) { io.stepAbove.forEach(function (d) { return d.disconnect(); }); }\n\n    io.stepAbove = stepEl.map(function (el, i) {\n      var marginTop = stepOffsetHeight[i];\n      var marginBottom = -vh + offsetMargin;\n      var rootMargin = marginTop + \"px 0px \" + marginBottom + \"px 0px\";\n\n      var options = {\n        root: null,\n        rootMargin: rootMargin,\n        threshold: 0\n      };\n\n      var obs = new IntersectionObserver(intersectStepAbove, options);\n      obs.observe(el);\n      return obs;\n    });\n  }\n\n  // bottom edge\n  function updateStepBelowIO() {\n    if (io.stepBelow) { io.stepBelow.forEach(function (d) { return d.disconnect(); }); }\n\n    io.stepBelow = stepEl.map(function (el, i) {\n      var marginTop = -offsetMargin;\n      var marginBottom = ph - vh + stepOffsetHeight[i] + offsetMargin;\n      var rootMargin = marginTop + \"px 0px \" + marginBottom + \"px 0px\";\n\n      var options = {\n        root: null,\n        rootMargin: rootMargin,\n        threshold: 0\n      };\n\n      var obs = new IntersectionObserver(intersectStepBelow, options);\n      obs.observe(el);\n      return obs;\n    });\n  }\n\n  // jump into viewport\n  function updateViewportAboveIO() {\n    if (io.viewportAbove) { io.viewportAbove.forEach(function (d) { return d.disconnect(); }); }\n    io.viewportAbove = stepEl.map(function (el, i) {\n      var marginTop = stepOffsetTop[i];\n      var marginBottom = -(vh - offsetMargin + stepOffsetHeight[i]);\n      var rootMargin = marginTop + \"px 0px \" + marginBottom + \"px 0px\";\n      var options = {\n        root: null,\n        rootMargin: rootMargin,\n        threshold: 0\n      };\n\n      var obs = new IntersectionObserver(intersectViewportAbove, options);\n      obs.observe(el);\n      return obs;\n    });\n  }\n\n  function updateViewportBelowIO() {\n    if (io.viewportBelow) { io.viewportBelow.forEach(function (d) { return d.disconnect(); }); }\n    io.viewportBelow = stepEl.map(function (el, i) {\n      var marginTop = -(offsetMargin + stepOffsetHeight[i]);\n      var marginBottom =\n        ph - stepOffsetTop[i] - stepOffsetHeight[i] - offsetMargin;\n      var rootMargin = marginTop + \"px 0px \" + marginBottom + \"px 0px\";\n      var options = {\n        root: null,\n        rootMargin: rootMargin,\n        threshold: 0\n      };\n\n      var obs = new IntersectionObserver(intersectViewportBelow, options);\n      obs.observe(el);\n      return obs;\n    });\n  }\n\n  // progress progress tracker\n  function updateStepProgressIO() {\n    if (io.stepProgress) { io.stepProgress.forEach(function (d) { return d.disconnect(); }); }\n\n    io.stepProgress = stepEl.map(function (el, i) {\n      var marginTop = stepOffsetHeight[i] - offsetMargin;\n      var marginBottom = -vh + offsetMargin;\n      var rootMargin = marginTop + \"px 0px \" + marginBottom + \"px 0px\";\n\n      var threshold = createThreshold(stepOffsetHeight[i]);\n      var options = {\n        root: null,\n        rootMargin: rootMargin,\n        threshold: threshold\n      };\n\n      var obs = new IntersectionObserver(intersectStepProgress, options);\n      obs.observe(el);\n      return obs;\n    });\n  }\n\n  function updateIO() {\n    updateViewportAboveIO();\n    updateViewportBelowIO();\n    updateStepAboveIO();\n    updateStepBelowIO();\n\n    if (progressMode) { updateStepProgressIO(); }\n\n    if (containerEl && graphicEl) {\n      updateTopIO();\n      updateBottomIO();\n    }\n  }\n\n  // SETUP FUNCTIONS\n\n  function indexSteps() {\n    stepEl.forEach(function (el, i) { return el.setAttribute('data-scrollama-index', i); });\n  }\n\n  function setupStates() {\n    stepStates = stepEl.map(function () { return ({\n      direction: null,\n      state: null\n    }); });\n\n    containerState = { direction: null, state: null };\n  }\n\n  function addDebug() {\n    if (debugMode) { setup({ id: id, stepEl: stepEl, offsetVal: offsetVal }); }\n  }\n\n  var S = {};\n\n  S.setup = function (ref) {\n    var container = ref.container;\n    var graphic = ref.graphic;\n    var step = ref.step;\n    var offset = ref.offset; if ( offset === void 0 ) offset = 0.5;\n    var progress = ref.progress; if ( progress === void 0 ) progress = false;\n    var threshold = ref.threshold; if ( threshold === void 0 ) threshold = 4;\n    var debug = ref.debug; if ( debug === void 0 ) debug = false;\n    var order = ref.order; if ( order === void 0 ) order = true;\n    var once = ref.once; if ( once === void 0 ) once = false;\n\n    id = generateId();\n    // elements\n    stepEl = selectAll(step);\n    containerEl = container ? select(container) : null;\n    graphicEl = graphic ? select(graphic) : null;\n\n    // error if no step selected\n    if (!stepEl.length) {\n      console.error('scrollama error: no step elements');\n      return S;\n    }\n\n    // options\n    debugMode = debug;\n    progressMode = progress;\n    preserveOrder = order;\n    triggerOnce = once;\n\n    S.offsetTrigger(offset);\n    progressThreshold = Math.max(1, +threshold);\n\n    isReady = true;\n\n    // customize\n    addDebug();\n    indexSteps();\n    setupStates();\n    handleResize();\n    handleEnable(true);\n    return S;\n  };\n\n  S.resize = function () {\n    handleResize();\n    return S;\n  };\n\n  S.enable = function () {\n    handleEnable(true);\n    return S;\n  };\n\n  S.disable = function () {\n    handleEnable(false);\n    return S;\n  };\n\n  S.destroy = function () {\n    handleEnable(false);\n    Object.keys(callback).forEach(function (c) { return (callback[c] = null); });\n    Object.keys(io).forEach(function (i) { return (io[i] = null); });\n  };\n\n  S.offsetTrigger = function(x) {\n    if (x && !isNaN(x)) {\n      offsetVal = Math.min(Math.max(0, x), 1);\n      return S;\n    }\n    return offsetVal;\n  };\n\n  S.onStepEnter = function (cb) {\n    callback.stepEnter = cb;\n    return S;\n  };\n\n  S.onStepExit = function (cb) {\n    callback.stepExit = cb;\n    return S;\n  };\n\n  S.onStepProgress = function (cb) {\n    callback.stepProgress = cb;\n    return S;\n  };\n\n  S.onContainerEnter = function (cb) {\n    callback.containerEnter = cb;\n    return S;\n  };\n\n  S.onContainerExit = function (cb) {\n    callback.containerExit = cb;\n    return S;\n  };\n\n  return S;\n}\n\nreturn scrollama;\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_scrollama@1.4.4@scrollama/build/scrollama.js\n// module id = 165\n// module chunks = 5","/*!\r\n  * Stickyfill – `position: sticky` polyfill\r\n  * v. 2.1.0 | https://github.com/wilddeer/stickyfill\r\n  * MIT License\r\n  */\r\n\r\n;(function(window, document) {\r\n    'use strict';\r\n    \r\n    /*\r\n     * 1. Check if the browser supports `position: sticky` natively or is too old to run the polyfill.\r\n     *    If either of these is the case set `seppuku` flag. It will be checked later to disable key features\r\n     *    of the polyfill, but the API will remain functional to avoid breaking things.\r\n     */\r\n    \r\n    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\r\n    \r\n    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n    \r\n    var seppuku = false;\r\n    \r\n    var isWindowDefined = typeof window !== 'undefined';\r\n    \r\n    // The polyfill can’t function properly without `window` or `window.getComputedStyle`.\r\n    if (!isWindowDefined || !window.getComputedStyle) seppuku = true;\r\n    // Dont’t get in a way if the browser supports `position: sticky` natively.\r\n    else {\r\n            (function () {\r\n                var testNode = document.createElement('div');\r\n    \r\n                if (['', '-webkit-', '-moz-', '-ms-'].some(function (prefix) {\r\n                    try {\r\n                        testNode.style.position = prefix + 'sticky';\r\n                    } catch (e) {}\r\n    \r\n                    return testNode.style.position != '';\r\n                })) seppuku = true;\r\n            })();\r\n        }\r\n    \r\n    /*\r\n     * 2. “Global” vars used across the polyfill\r\n     */\r\n    var isInitialized = false;\r\n    \r\n    // Check if Shadow Root constructor exists to make further checks simpler\r\n    var shadowRootExists = typeof ShadowRoot !== 'undefined';\r\n    \r\n    // Last saved scroll position\r\n    var scroll = {\r\n        top: null,\r\n        left: null\r\n    };\r\n    \r\n    // Array of created Sticky instances\r\n    var stickies = [];\r\n    \r\n    /*\r\n     * 3. Utility functions\r\n     */\r\n    function extend(targetObj, sourceObject) {\r\n        for (var key in sourceObject) {\r\n            if (sourceObject.hasOwnProperty(key)) {\r\n                targetObj[key] = sourceObject[key];\r\n            }\r\n        }\r\n    }\r\n    \r\n    function parseNumeric(val) {\r\n        return parseFloat(val) || 0;\r\n    }\r\n    \r\n    function getDocOffsetTop(node) {\r\n        var docOffsetTop = 0;\r\n    \r\n        while (node) {\r\n            docOffsetTop += node.offsetTop;\r\n            node = node.offsetParent;\r\n        }\r\n    \r\n        return docOffsetTop;\r\n    }\r\n    \r\n    /*\r\n     * 4. Sticky class\r\n     */\r\n    \r\n    var Sticky = function () {\r\n        function Sticky(node) {\r\n            _classCallCheck(this, Sticky);\r\n    \r\n            if (!(node instanceof HTMLElement)) throw new Error('First argument must be HTMLElement');\r\n            if (stickies.some(function (sticky) {\r\n                return sticky._node === node;\r\n            })) throw new Error('Stickyfill is already applied to this node');\r\n    \r\n            this._node = node;\r\n            this._stickyMode = null;\r\n            this._active = false;\r\n    \r\n            stickies.push(this);\r\n    \r\n            this.refresh();\r\n        }\r\n    \r\n        _createClass(Sticky, [{\r\n            key: 'refresh',\r\n            value: function refresh() {\r\n                if (seppuku || this._removed) return;\r\n                if (this._active) this._deactivate();\r\n    \r\n                var node = this._node;\r\n    \r\n                /*\r\n                 * 1. Save node computed props\r\n                 */\r\n                var nodeComputedStyle = getComputedStyle(node);\r\n                var nodeComputedProps = {\r\n                    position: nodeComputedStyle.position,\r\n                    top: nodeComputedStyle.top,\r\n                    display: nodeComputedStyle.display,\r\n                    marginTop: nodeComputedStyle.marginTop,\r\n                    marginBottom: nodeComputedStyle.marginBottom,\r\n                    marginLeft: nodeComputedStyle.marginLeft,\r\n                    marginRight: nodeComputedStyle.marginRight,\r\n                    cssFloat: nodeComputedStyle.cssFloat\r\n                };\r\n    \r\n                /*\r\n                 * 2. Check if the node can be activated\r\n                 */\r\n                if (isNaN(parseFloat(nodeComputedProps.top)) || nodeComputedProps.display == 'table-cell' || nodeComputedProps.display == 'none') return;\r\n    \r\n                this._active = true;\r\n    \r\n                /*\r\n                 * 3. Check if the current node position is `sticky`. If it is, it means that the browser supports sticky positioning,\r\n                 *    but the polyfill was force-enabled. We set the node’s position to `static` before continuing, so that the node\r\n                 *    is in it’s initial position when we gather its params.\r\n                 */\r\n                var originalPosition = node.style.position;\r\n                if (nodeComputedStyle.position == 'sticky' || nodeComputedStyle.position == '-webkit-sticky') node.style.position = 'static';\r\n    \r\n                /*\r\n                 * 4. Get necessary node parameters\r\n                 */\r\n                var referenceNode = node.parentNode;\r\n                var parentNode = shadowRootExists && referenceNode instanceof ShadowRoot ? referenceNode.host : referenceNode;\r\n                var nodeWinOffset = node.getBoundingClientRect();\r\n                var parentWinOffset = parentNode.getBoundingClientRect();\r\n                var parentComputedStyle = getComputedStyle(parentNode);\r\n    \r\n                this._parent = {\r\n                    node: parentNode,\r\n                    styles: {\r\n                        position: parentNode.style.position\r\n                    },\r\n                    offsetHeight: parentNode.offsetHeight\r\n                };\r\n                this._offsetToWindow = {\r\n                    left: nodeWinOffset.left,\r\n                    right: document.documentElement.clientWidth - nodeWinOffset.right\r\n                };\r\n                this._offsetToParent = {\r\n                    top: nodeWinOffset.top - parentWinOffset.top - parseNumeric(parentComputedStyle.borderTopWidth),\r\n                    left: nodeWinOffset.left - parentWinOffset.left - parseNumeric(parentComputedStyle.borderLeftWidth),\r\n                    right: -nodeWinOffset.right + parentWinOffset.right - parseNumeric(parentComputedStyle.borderRightWidth)\r\n                };\r\n                this._styles = {\r\n                    position: originalPosition,\r\n                    top: node.style.top,\r\n                    bottom: node.style.bottom,\r\n                    left: node.style.left,\r\n                    right: node.style.right,\r\n                    width: node.style.width,\r\n                    marginTop: node.style.marginTop,\r\n                    marginLeft: node.style.marginLeft,\r\n                    marginRight: node.style.marginRight\r\n                };\r\n    \r\n                var nodeTopValue = parseNumeric(nodeComputedProps.top);\r\n                this._limits = {\r\n                    start: nodeWinOffset.top + window.pageYOffset - nodeTopValue,\r\n                    end: parentWinOffset.top + window.pageYOffset + parentNode.offsetHeight - parseNumeric(parentComputedStyle.borderBottomWidth) - node.offsetHeight - nodeTopValue - parseNumeric(nodeComputedProps.marginBottom)\r\n                };\r\n    \r\n                /*\r\n                 * 5. Ensure that the node will be positioned relatively to the parent node\r\n                 */\r\n                var parentPosition = parentComputedStyle.position;\r\n    \r\n                if (parentPosition != 'absolute' && parentPosition != 'relative') {\r\n                    parentNode.style.position = 'relative';\r\n                }\r\n    \r\n                /*\r\n                 * 6. Recalc node position.\r\n                 *    It’s important to do this before clone injection to avoid scrolling bug in Chrome.\r\n                 */\r\n                this._recalcPosition();\r\n    \r\n                /*\r\n                 * 7. Create a clone\r\n                 */\r\n                var clone = this._clone = {};\r\n                clone.node = document.createElement('div');\r\n    \r\n                // Apply styles to the clone\r\n                extend(clone.node.style, {\r\n                    width: nodeWinOffset.right - nodeWinOffset.left + 'px',\r\n                    height: nodeWinOffset.bottom - nodeWinOffset.top + 'px',\r\n                    marginTop: nodeComputedProps.marginTop,\r\n                    marginBottom: nodeComputedProps.marginBottom,\r\n                    marginLeft: nodeComputedProps.marginLeft,\r\n                    marginRight: nodeComputedProps.marginRight,\r\n                    cssFloat: nodeComputedProps.cssFloat,\r\n                    padding: 0,\r\n                    border: 0,\r\n                    borderSpacing: 0,\r\n                    fontSize: '1em',\r\n                    position: 'static'\r\n                });\r\n    \r\n                referenceNode.insertBefore(clone.node, node);\r\n                clone.docOffsetTop = getDocOffsetTop(clone.node);\r\n            }\r\n        }, {\r\n            key: '_recalcPosition',\r\n            value: function _recalcPosition() {\r\n                if (!this._active || this._removed) return;\r\n    \r\n                var stickyMode = scroll.top <= this._limits.start ? 'start' : scroll.top >= this._limits.end ? 'end' : 'middle';\r\n    \r\n                if (this._stickyMode == stickyMode) return;\r\n    \r\n                switch (stickyMode) {\r\n                    case 'start':\r\n                        extend(this._node.style, {\r\n                            position: 'absolute',\r\n                            left: this._offsetToParent.left + 'px',\r\n                            right: this._offsetToParent.right + 'px',\r\n                            top: this._offsetToParent.top + 'px',\r\n                            bottom: 'auto',\r\n                            width: 'auto',\r\n                            marginLeft: 0,\r\n                            marginRight: 0,\r\n                            marginTop: 0\r\n                        });\r\n                        break;\r\n    \r\n                    case 'middle':\r\n                        extend(this._node.style, {\r\n                            position: 'fixed',\r\n                            left: this._offsetToWindow.left + 'px',\r\n                            right: this._offsetToWindow.right + 'px',\r\n                            top: this._styles.top,\r\n                            bottom: 'auto',\r\n                            width: 'auto',\r\n                            marginLeft: 0,\r\n                            marginRight: 0,\r\n                            marginTop: 0\r\n                        });\r\n                        break;\r\n    \r\n                    case 'end':\r\n                        extend(this._node.style, {\r\n                            position: 'absolute',\r\n                            left: this._offsetToParent.left + 'px',\r\n                            right: this._offsetToParent.right + 'px',\r\n                            top: 'auto',\r\n                            bottom: 0,\r\n                            width: 'auto',\r\n                            marginLeft: 0,\r\n                            marginRight: 0\r\n                        });\r\n                        break;\r\n                }\r\n    \r\n                this._stickyMode = stickyMode;\r\n            }\r\n        }, {\r\n            key: '_fastCheck',\r\n            value: function _fastCheck() {\r\n                if (!this._active || this._removed) return;\r\n    \r\n                if (Math.abs(getDocOffsetTop(this._clone.node) - this._clone.docOffsetTop) > 1 || Math.abs(this._parent.node.offsetHeight - this._parent.offsetHeight) > 1) this.refresh();\r\n            }\r\n        }, {\r\n            key: '_deactivate',\r\n            value: function _deactivate() {\r\n                var _this = this;\r\n    \r\n                if (!this._active || this._removed) return;\r\n    \r\n                this._clone.node.parentNode.removeChild(this._clone.node);\r\n                delete this._clone;\r\n    \r\n                extend(this._node.style, this._styles);\r\n                delete this._styles;\r\n    \r\n                // Check whether element’s parent node is used by other stickies.\r\n                // If not, restore parent node’s styles.\r\n                if (!stickies.some(function (sticky) {\r\n                    return sticky !== _this && sticky._parent && sticky._parent.node === _this._parent.node;\r\n                })) {\r\n                    extend(this._parent.node.style, this._parent.styles);\r\n                }\r\n                delete this._parent;\r\n    \r\n                this._stickyMode = null;\r\n                this._active = false;\r\n    \r\n                delete this._offsetToWindow;\r\n                delete this._offsetToParent;\r\n                delete this._limits;\r\n            }\r\n        }, {\r\n            key: 'remove',\r\n            value: function remove() {\r\n                var _this2 = this;\r\n    \r\n                this._deactivate();\r\n    \r\n                stickies.some(function (sticky, index) {\r\n                    if (sticky._node === _this2._node) {\r\n                        stickies.splice(index, 1);\r\n                        return true;\r\n                    }\r\n                });\r\n    \r\n                this._removed = true;\r\n            }\r\n        }]);\r\n    \r\n        return Sticky;\r\n    }();\r\n    \r\n    /*\r\n     * 5. Stickyfill API\r\n     */\r\n    \r\n    \r\n    var Stickyfill = {\r\n        stickies: stickies,\r\n        Sticky: Sticky,\r\n    \r\n        forceSticky: function forceSticky() {\r\n            seppuku = false;\r\n            init();\r\n    \r\n            this.refreshAll();\r\n        },\r\n        addOne: function addOne(node) {\r\n            // Check whether it’s a node\r\n            if (!(node instanceof HTMLElement)) {\r\n                // Maybe it’s a node list of some sort?\r\n                // Take first node from the list then\r\n                if (node.length && node[0]) node = node[0];else return;\r\n            }\r\n    \r\n            // Check if Stickyfill is already applied to the node\r\n            // and return existing sticky\r\n            for (var i = 0; i < stickies.length; i++) {\r\n                if (stickies[i]._node === node) return stickies[i];\r\n            }\r\n    \r\n            // Create and return new sticky\r\n            return new Sticky(node);\r\n        },\r\n        add: function add(nodeList) {\r\n            // If it’s a node make an array of one node\r\n            if (nodeList instanceof HTMLElement) nodeList = [nodeList];\r\n            // Check if the argument is an iterable of some sort\r\n            if (!nodeList.length) return;\r\n    \r\n            // Add every element as a sticky and return an array of created Sticky instances\r\n            var addedStickies = [];\r\n    \r\n            var _loop = function _loop(i) {\r\n                var node = nodeList[i];\r\n    \r\n                // If it’s not an HTMLElement – create an empty element to preserve 1-to-1\r\n                // correlation with input list\r\n                if (!(node instanceof HTMLElement)) {\r\n                    addedStickies.push(void 0);\r\n                    return 'continue';\r\n                }\r\n    \r\n                // If Stickyfill is already applied to the node\r\n                // add existing sticky\r\n                if (stickies.some(function (sticky) {\r\n                    if (sticky._node === node) {\r\n                        addedStickies.push(sticky);\r\n                        return true;\r\n                    }\r\n                })) return 'continue';\r\n    \r\n                // Create and add new sticky\r\n                addedStickies.push(new Sticky(node));\r\n            };\r\n    \r\n            for (var i = 0; i < nodeList.length; i++) {\r\n                var _ret2 = _loop(i);\r\n    \r\n                if (_ret2 === 'continue') continue;\r\n            }\r\n    \r\n            return addedStickies;\r\n        },\r\n        refreshAll: function refreshAll() {\r\n            stickies.forEach(function (sticky) {\r\n                return sticky.refresh();\r\n            });\r\n        },\r\n        removeOne: function removeOne(node) {\r\n            // Check whether it’s a node\r\n            if (!(node instanceof HTMLElement)) {\r\n                // Maybe it’s a node list of some sort?\r\n                // Take first node from the list then\r\n                if (node.length && node[0]) node = node[0];else return;\r\n            }\r\n    \r\n            // Remove the stickies bound to the nodes in the list\r\n            stickies.some(function (sticky) {\r\n                if (sticky._node === node) {\r\n                    sticky.remove();\r\n                    return true;\r\n                }\r\n            });\r\n        },\r\n        remove: function remove(nodeList) {\r\n            // If it’s a node make an array of one node\r\n            if (nodeList instanceof HTMLElement) nodeList = [nodeList];\r\n            // Check if the argument is an iterable of some sort\r\n            if (!nodeList.length) return;\r\n    \r\n            // Remove the stickies bound to the nodes in the list\r\n    \r\n            var _loop2 = function _loop2(i) {\r\n                var node = nodeList[i];\r\n    \r\n                stickies.some(function (sticky) {\r\n                    if (sticky._node === node) {\r\n                        sticky.remove();\r\n                        return true;\r\n                    }\r\n                });\r\n            };\r\n    \r\n            for (var i = 0; i < nodeList.length; i++) {\r\n                _loop2(i);\r\n            }\r\n        },\r\n        removeAll: function removeAll() {\r\n            while (stickies.length) {\r\n                stickies[0].remove();\r\n            }\r\n        }\r\n    };\r\n    \r\n    /*\r\n     * 6. Setup events (unless the polyfill was disabled)\r\n     */\r\n    function init() {\r\n        if (isInitialized) {\r\n            return;\r\n        }\r\n    \r\n        isInitialized = true;\r\n    \r\n        // Watch for scroll position changes and trigger recalc/refresh if needed\r\n        function checkScroll() {\r\n            if (window.pageXOffset != scroll.left) {\r\n                scroll.top = window.pageYOffset;\r\n                scroll.left = window.pageXOffset;\r\n    \r\n                Stickyfill.refreshAll();\r\n            } else if (window.pageYOffset != scroll.top) {\r\n                scroll.top = window.pageYOffset;\r\n                scroll.left = window.pageXOffset;\r\n    \r\n                // recalc position for all stickies\r\n                stickies.forEach(function (sticky) {\r\n                    return sticky._recalcPosition();\r\n                });\r\n            }\r\n        }\r\n    \r\n        checkScroll();\r\n        window.addEventListener('scroll', checkScroll);\r\n    \r\n        // Watch for window resizes and device orientation changes and trigger refresh\r\n        window.addEventListener('resize', Stickyfill.refreshAll);\r\n        window.addEventListener('orientationchange', Stickyfill.refreshAll);\r\n    \r\n        //Fast dirty check for layout changes every 500ms\r\n        var fastCheckTimer = void 0;\r\n    \r\n        function startFastCheckTimer() {\r\n            fastCheckTimer = setInterval(function () {\r\n                stickies.forEach(function (sticky) {\r\n                    return sticky._fastCheck();\r\n                });\r\n            }, 500);\r\n        }\r\n    \r\n        function stopFastCheckTimer() {\r\n            clearInterval(fastCheckTimer);\r\n        }\r\n    \r\n        var docHiddenKey = void 0;\r\n        var visibilityChangeEventName = void 0;\r\n    \r\n        if ('hidden' in document) {\r\n            docHiddenKey = 'hidden';\r\n            visibilityChangeEventName = 'visibilitychange';\r\n        } else if ('webkitHidden' in document) {\r\n            docHiddenKey = 'webkitHidden';\r\n            visibilityChangeEventName = 'webkitvisibilitychange';\r\n        }\r\n    \r\n        if (visibilityChangeEventName) {\r\n            if (!document[docHiddenKey]) startFastCheckTimer();\r\n    \r\n            document.addEventListener(visibilityChangeEventName, function () {\r\n                if (document[docHiddenKey]) {\r\n                    stopFastCheckTimer();\r\n                } else {\r\n                    startFastCheckTimer();\r\n                }\r\n            });\r\n        } else startFastCheckTimer();\r\n    }\r\n    \r\n    if (!seppuku) init();\r\n    \r\n    /*\r\n     * 7. Expose Stickyfill\r\n     */\r\n    if (typeof module != 'undefined' && module.exports) {\r\n        module.exports = Stickyfill;\r\n    } else if (isWindowDefined) {\r\n        window.Stickyfill = Stickyfill;\r\n    }\r\n    \r\n})(window, document);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_stickyfilljs@2.1.0@stickyfilljs/dist/stickyfill.js\n// module id = 166\n// module chunks = 5","var Component = require(\"!../../../../node_modules/_vue-loader@10.3.0@vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../../../../node_modules/_vue-loader@10.3.0@vue-loader/lib/selector?type=script&index=0!../../../../node_modules/_string-replace-webpack-plugin@0.1.3@string-replace-webpack-plugin/loader.js?id=tm1l2r4ciqb!./sticky-panel.vue\"),\n  /* template */\n  require(\"!!../../../../node_modules/_vue-loader@10.3.0@vue-loader/lib/template-compiler?id=data-v-1838271a!../../../../node_modules/_vue-loader@10.3.0@vue-loader/lib/selector?type=template&index=0!../../../../node_modules/_string-replace-webpack-plugin@0.1.3@string-replace-webpack-plugin/loader.js?id=tm1l2r4ciqb!./sticky-panel.vue\"),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/stickynav/src/sticky-panel.vue\n// module id = 232\n// module chunks = 5","\n/* styles */\nrequire(\"!!vue-loader/node_modules/vue-style-loader!css-loader?minimize!../../../../node_modules/_vue-loader@10.3.0@vue-loader/lib/style-rewriter?id=data-v-6b20fd57&scoped=true!less-loader!../../../../node_modules/_vue-loader@10.3.0@vue-loader/lib/selector?type=styles&index=0!../../../../node_modules/_string-replace-webpack-plugin@0.1.3@string-replace-webpack-plugin/loader.js?id=tm1l2r4ciqb!./stickynav.vue\")\n\nvar Component = require(\"!../../../../node_modules/_vue-loader@10.3.0@vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../../../../node_modules/_vue-loader@10.3.0@vue-loader/lib/selector?type=script&index=0!../../../../node_modules/_string-replace-webpack-plugin@0.1.3@string-replace-webpack-plugin/loader.js?id=tm1l2r4ciqb!./stickynav.vue\"),\n  /* template */\n  require(\"!!../../../../node_modules/_vue-loader@10.3.0@vue-loader/lib/template-compiler?id=data-v-6b20fd57!../../../../node_modules/_vue-loader@10.3.0@vue-loader/lib/selector?type=template&index=0!../../../../node_modules/_string-replace-webpack-plugin@0.1.3@string-replace-webpack-plugin/loader.js?id=tm1l2r4ciqb!./stickynav.vue\"),\n  /* scopeId */\n  \"data-v-6b20fd57\",\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/stickynav/src/stickynav.vue\n// module id = 233\n// module chunks = 5","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"step\",\n    class: _vm.classes\n  }, [_vm._t(\"default\")], 2)\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_vue-loader@10.3.0@vue-loader/lib/template-compiler.js?id=data-v-1838271a!./~/_vue-loader@10.3.0@vue-loader/lib/selector.js?type=template&index=0!./~/_string-replace-webpack-plugin@0.1.3@string-replace-webpack-plugin/loader.js?id=tm1l2r4ciqb!./src/components/stickynav/src/sticky-panel.vue\n// module id = 250\n// module chunks = 5","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    ref: \"wrapper\",\n    staticClass: \"wrapper\"\n  }, [_c('div', {\n    ref: \"banner\"\n  }, [_vm._t(\"banner\")], 2), _vm._v(\" \"), _c('div', {\n    staticClass: \"scroll\"\n  }, [_c('div', {\n    ref: \"stickyNav\",\n    staticClass: \"scroll__graphic\"\n  }, [_c('ul', {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: (_vm.navList.length > 0),\n      expression: \"navList.length > 0\"\n    }],\n    staticClass: \"sticky-nav\",\n    style: ({\n      color: _vm.activeColor\n    })\n  }, _vm._l((_vm.navList), function(item, key) {\n    return _c('li', {\n      key: key,\n      staticClass: \"yd-tab-nav-item\",\n      class: item._uid == _vm.activeIndex ? 'yd-tab-active' : '',\n      on: {\n        \"click\": function($event) {\n          _vm.changeHandler(item._uid, item.label, item.tabkey, item.panel, key)\n        }\n      }\n    }, [_c('a', {\n      attrs: {\n        \"href\": \"javascript:;\"\n      }\n    }, [_vm._v(_vm._s(item.label))])])\n  }))]), _vm._v(\" \"), _c('div', {\n    ref: \"panel\",\n    staticClass: \"yd-sticky-panel\"\n  }, [_vm._t(\"default\")], 2)]), _vm._v(\" \"), _c('div', {\n    staticClass: \"yd-lyout-footer\"\n  }, [_vm._t(\"footer\")], 2)])\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_vue-loader@10.3.0@vue-loader/lib/template-compiler.js?id=data-v-6b20fd57!./~/_vue-loader@10.3.0@vue-loader/lib/selector.js?type=template&index=0!./~/_string-replace-webpack-plugin@0.1.3@string-replace-webpack-plugin/loader.js?id=tm1l2r4ciqb!./src/components/stickynav/src/stickynav.vue\n// module id = 290\n// module chunks = 5","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../../node_modules/_css-loader@0.26.4@css-loader/index.js?minimize!../../../../node_modules/_vue-loader@10.3.0@vue-loader/lib/style-rewriter.js?id=data-v-6b20fd57&scoped=true!../../../../node_modules/_less-loader@2.2.3@less-loader/index.js!../../../../node_modules/_vue-loader@10.3.0@vue-loader/lib/selector.js?type=styles&index=0!../../../../node_modules/_string-replace-webpack-plugin@0.1.3@string-replace-webpack-plugin/loader.js?id=tm1l2r4ciqb!./stickynav.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../../../node_modules/_vue-style-loader@2.0.5@vue-style-loader/lib/addStylesClient.js\")(\"605ef899\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_vue-style-loader@2.0.5@vue-style-loader!./~/_css-loader@0.26.4@css-loader?minimize!./~/_vue-loader@10.3.0@vue-loader/lib/style-rewriter.js?id=data-v-6b20fd57&scoped=true!./~/_less-loader@2.2.3@less-loader!./~/_vue-loader@10.3.0@vue-loader/lib/selector.js?type=styles&index=0!./~/_string-replace-webpack-plugin@0.1.3@string-replace-webpack-plugin/loader.js?id=tm1l2r4ciqb!./src/components/stickynav/src/stickynav.vue\n// module id = 341\n// module chunks = 5"],"sourceRoot":""}